["^ ","~:output",["^ ","~:js","goog.provide('instaparse.transform');\ngoog.require('cljs.core');\ngoog.require('instaparse.gll');\ngoog.require('instaparse.util');\ninstaparse.transform.map_preserving_meta = (function instaparse$transform$map_preserving_meta(f,l){\nreturn cljs.core.with_meta(cljs.core.map.cljs$core$IFn$_invoke$arity$2(f,l),cljs.core.meta(l));\n});\n/**\n * This variation of the merge-meta in gll does nothing if obj is not\n * something that can have a metamap attached.\n */\ninstaparse.transform.merge_meta = (function instaparse$transform$merge_meta(obj,metamap){\nif(((!((obj == null)))?((((obj.cljs$lang$protocol_mask$partition0$ & (262144))) || ((cljs.core.PROTOCOL_SENTINEL === obj.cljs$core$IWithMeta$)))?true:(((!obj.cljs$lang$protocol_mask$partition0$))?cljs.core.native_satisfies_QMARK_(cljs.core.IWithMeta,obj):false)):cljs.core.native_satisfies_QMARK_(cljs.core.IWithMeta,obj))){\nreturn instaparse.gll.merge_meta(obj,metamap);\n} else {\nreturn obj;\n}\n});\ninstaparse.transform.enlive_transform = (function instaparse$transform$enlive_transform(transform_map,parse_tree){\nvar transform = (function (){var G__30997 = new cljs.core.Keyword(null,\"tag\",\"tag\",-1290361223).cljs$core$IFn$_invoke$arity$1(parse_tree);\nreturn (transform_map.cljs$core$IFn$_invoke$arity$1 ? transform_map.cljs$core$IFn$_invoke$arity$1(G__30997) : transform_map.call(null,G__30997));\n})();\nif(cljs.core.truth_(transform)){\nreturn instaparse.transform.merge_meta(cljs.core.apply.cljs$core$IFn$_invoke$arity$2(transform,cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(instaparse.transform.enlive_transform,transform_map),new cljs.core.Keyword(null,\"content\",\"content\",15833224).cljs$core$IFn$_invoke$arity$1(parse_tree))),cljs.core.meta(parse_tree));\n} else {\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"tag\",\"tag\",-1290361223).cljs$core$IFn$_invoke$arity$1(parse_tree))){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(parse_tree,new cljs.core.Keyword(null,\"content\",\"content\",15833224),cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(instaparse.transform.enlive_transform,transform_map),new cljs.core.Keyword(null,\"content\",\"content\",15833224).cljs$core$IFn$_invoke$arity$1(parse_tree)));\n} else {\nreturn parse_tree;\n\n}\n}\n});\ninstaparse.transform.hiccup_transform = (function instaparse$transform$hiccup_transform(transform_map,parse_tree){\nif((cljs.core.sequential_QMARK_(parse_tree)) && (cljs.core.seq(parse_tree))){\nvar temp__5455__auto__ = (function (){var G__30998 = cljs.core.first(parse_tree);\nreturn (transform_map.cljs$core$IFn$_invoke$arity$1 ? transform_map.cljs$core$IFn$_invoke$arity$1(G__30998) : transform_map.call(null,G__30998));\n})();\nif(cljs.core.truth_(temp__5455__auto__)){\nvar transform = temp__5455__auto__;\nreturn instaparse.transform.merge_meta(cljs.core.apply.cljs$core$IFn$_invoke$arity$2(transform,cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(instaparse.transform.hiccup_transform,transform_map),cljs.core.next(parse_tree))),cljs.core.meta(parse_tree));\n} else {\nreturn cljs.core.with_meta(cljs.core.into.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.first(parse_tree)], null),cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(instaparse.transform.hiccup_transform,transform_map),cljs.core.next(parse_tree))),cljs.core.meta(parse_tree));\n}\n} else {\nreturn parse_tree;\n}\n});\n/**\n * Takes a transform map and a parse tree (or seq of parse-trees).\n * A transform map is a mapping from tags to \n * functions that take a node's contents and return\n * a replacement for the node, i.e.,\n * {:node-tag (fn [child1 child2 ...] node-replacement),\n *  :another-node-tag (fn [child1 child2 ...] node-replacement)}\n */\ninstaparse.transform.transform = (function instaparse$transform$transform(transform_map,parse_tree){\nif(typeof parse_tree === 'string'){\nreturn parse_tree;\n} else {\nif(cljs.core.truth_((function (){var and__5114__auto__ = cljs.core.map_QMARK_(parse_tree);\nif(and__5114__auto__){\nreturn new cljs.core.Keyword(null,\"tag\",\"tag\",-1290361223).cljs$core$IFn$_invoke$arity$1(parse_tree);\n} else {\nreturn and__5114__auto__;\n}\n})())){\nreturn instaparse.transform.enlive_transform(transform_map,parse_tree);\n} else {\nif((cljs.core.vector_QMARK_(parse_tree)) && ((cljs.core.first(parse_tree) instanceof cljs.core.Keyword))){\nreturn instaparse.transform.hiccup_transform(transform_map,parse_tree);\n} else {\nif(cljs.core.sequential_QMARK_(parse_tree)){\nreturn instaparse.transform.map_preserving_meta(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(instaparse.transform.transform,transform_map),parse_tree);\n} else {\nif((parse_tree instanceof instaparse.gll.Failure)){\nreturn parse_tree;\n} else {\nreturn instaparse.util.throw_illegal_argument_exception.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"Invalid parse-tree, not recognized as either enlive or hiccup format.\"], 0));\n\n}\n}\n}\n}\n}\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:doc","Functions to transform parse trees"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$instaparse.transform","~:op","~:ns","~:imports",null,"~:requires",["^ ","~$instaparse.gll","^@","~$instaparse.util","^A","~$cljs.core","^B","~$goog","^C"],"~:seen",["^9",["~:require"]],"~:uses",["^ ","~$throw-illegal-argument-exception","^A"],"~:require-macros",["^ ","^B","^B","^@","^@"],"~:form",["~#list",["~$ns","^;","Functions to transform parse trees",["^J",["^E",["^@"],["^A","~:refer",["^G"]]]]]],"~:flags",["^ ","^E",["^9",[]]],"~:js-deps",["^ "],"~:deps",["^C","^B","^@","^A"]],"^=","^;","~:resource-id",["~:shadow.build.classpath/resource","instaparse/transform.cljc"],"~:compiled-at",1548711932746,"~:resource-name","instaparse/transform.cljc","~:warnings",[],"~:source","(ns instaparse.transform\r\n  \"Functions to transform parse trees\"\r\n  (:require [instaparse.gll]\r\n            [instaparse.util :refer [throw-illegal-argument-exception]]))\r\n\r\n(defn map-preserving-meta [f l]\r\n  (with-meta (map f l) (meta l)))\r\n\r\n(defn merge-meta\r\n  \"This variation of the merge-meta in gll does nothing if obj is not\r\nsomething that can have a metamap attached.\"\r\n  [obj metamap]\r\n  (if #?(:clj (instance? clojure.lang.IObj obj)\r\n         :cljs (satisfies? IWithMeta obj))\r\n    (instaparse.gll/merge-meta obj metamap)\r\n    obj))\r\n\r\n(defn- enlive-transform\r\n  [transform-map parse-tree]\r\n  (let [transform (transform-map (:tag parse-tree))]\r\n    (cond\r\n      transform\r\n      (merge-meta \r\n        (apply transform (map (partial enlive-transform transform-map)\r\n                              (:content parse-tree)))\r\n        (meta parse-tree))\r\n      (:tag parse-tree)\r\n      (assoc parse-tree :content (map (partial enlive-transform transform-map)\r\n                                      (:content parse-tree)))\r\n      :else\r\n      parse-tree)))\r\n\r\n(defn- hiccup-transform\r\n  [transform-map parse-tree]\r\n  (if (and (sequential? parse-tree) (seq parse-tree))\r\n    (if-let [transform (transform-map (first parse-tree))]\r\n      (merge-meta\r\n        (apply transform (map (partial hiccup-transform transform-map)\r\n                              (next parse-tree)))\r\n        (meta parse-tree))\r\n      (with-meta \r\n        (into [(first parse-tree)]\r\n              (map (partial hiccup-transform transform-map) \r\n                   (next parse-tree)))\r\n        (meta parse-tree)))\r\n    parse-tree))\r\n\r\n(defn transform\r\n  \"Takes a transform map and a parse tree (or seq of parse-trees).\r\n   A transform map is a mapping from tags to \r\n   functions that take a node's contents and return\r\n   a replacement for the node, i.e.,\r\n   {:node-tag (fn [child1 child2 ...] node-replacement),\r\n    :another-node-tag (fn [child1 child2 ...] node-replacement)}\"\r\n  [transform-map parse-tree]\r\n  ; Detect what kind of tree this is\r\n  (cond\r\n    (string? parse-tree)\r\n    ; This is a leaf of the tree that should pass through unchanged\r\n    parse-tree\r\n\r\n    (and (map? parse-tree) (:tag parse-tree))\r\n    ; This is an enlive tree-seq\r\n    (enlive-transform transform-map parse-tree)\r\n    \r\n    (and (vector? parse-tree) (keyword? (first parse-tree)))\r\n    ; This is a hiccup tree-seq\r\n    (hiccup-transform transform-map parse-tree)\r\n    \r\n    (sequential? parse-tree)\r\n    ; This is either a sequence of parse results, or a tree\r\n    ; with a hidden root tag.\r\n    (map-preserving-meta (partial transform transform-map) parse-tree)\r\n    \r\n    (instance? instaparse.gll.Failure parse-tree)\r\n    ; pass failures through unchanged\r\n    parse-tree\r\n    \r\n    :else\r\n    (throw-illegal-argument-exception\r\n      \"Invalid parse-tree, not recognized as either enlive or hiccup format.\")))\r\n","~:reader-features",["^9",["~:cljs"]],"~:source-map",["^ ","~i5",["^ ","~i0",[["^ ","~:gcol",0,"~:gline",4],["^ ","^Y",43,"^Z",4],["^ ","^Y",0,"^Z",5]],"~i6",[["^ ","^Y",0,"^Z",4,"^:","instaparse.transform/map-preserving-meta"]],"~i27",[["^ ","^Y",94,"^Z",4,"^:","f"]],"~i29",[["^ ","^Y",96,"^Z",4,"^:","l"]]],"~i6",["^ ","~i2",[["^ ","^Y",0,"^Z",5]],"~i3",[["^ ","^Y",7,"^Z",5,"^:","cljs.core/with-meta"]],"~i13",[["^ ","^Y",27,"^Z",5]],"~i14",[["^ ","^Y",27,"^Z",5,"^:","cljs.core.map.cljs$core$IFn$_invoke$arity$2"]],"~i18",[["^ ","^Y",71,"^Z",5,"^:","f"]],"~i20",[["^ ","^Y",73,"^Z",5,"^:","l"]],"~i23",[["^ ","^Y",76,"^Z",5]],"~i24",[["^ ","^Y",76,"^Z",5,"^:","cljs.core/meta"]],"^10",[["^ ","^Y",91,"^Z",5,"^:","l"]]],"~i8",["^ ","~i0",[["^ ","^Y",0,"^Z",7],["^ ","^Y",34,"^Z",11],["^ ","^Y",0,"^Z",12]],"~i6",[["^ ","^Y",0,"^Z",11,"^:","instaparse.transform/merge-meta"]]],"~i11",["^ ","~i3",[["^ ","^Y",76,"^Z",11,"^:","obj"]],"~i7",[["^ ","^Y",80,"^Z",11,"^:","metamap"]]],"~i12",["^ ","~i2",[["^ ","^Y",0,"^Z",12]]],"^11",["^ ","~i15",[["^ ","^Y",3,"^Z",12],["^ ","^Y",5,"^Z",12],["^ ","^Y",7,"^Z",12],["^ ","^Y",15,"^Z",12],["^ ","^Y",23,"^Z",12],["^ ","^Y",25,"^Z",12],["^ ","^Y",26,"^Z",12],["^ ","^Y",27,"^Z",12],["^ ","^Y",69,"^Z",12],["^ ","^Y",84,"^Z",12],["^ ","^Y",85,"^Z",12,"^:","cljs.core/PROTOCOL_SENTINEL"],["^ ","^Y",117,"^Z",12],["^ ","^Y",145,"^Z",12],["^ ","^Y",150,"^Z",12],["^ ","^Y",152,"^Z",12],["^ ","^Y",154,"^Z",12],["^ ","^Y",196,"^Z",12],["^ ","^Y",196,"^Z",12,"^:","cljs.core/native-satisfies?"],["^ ","^Y",255,"^Z",12],["^ ","^Y",263,"^Z",12],["^ ","^Y",263,"^Z",12,"^:","cljs.core/native-satisfies?"]],"^[",[["^ ","^Y",230,"^Z",12,"^:","cljs.core/IWithMeta"],["^ ","^Y",297,"^Z",12,"^:","cljs.core/IWithMeta"]],"~i37",[["^ ","^Y",8,"^Z",12,"^:","obj"],["^ ","^Y",27,"^Z",12,"^:","obj"],["^ ","^Y",117,"^Z",12,"^:","obj"],["^ ","^Y",154,"^Z",12,"^:","obj"],["^ ","^Y",250,"^Z",12,"^:","obj"],["^ ","^Y",317,"^Z",12,"^:","obj"]]],"^12",["^ ","~i4",[["^ ","^Y",0,"^Z",13]],"~i5",[["^ ","^Y",7,"^Z",13,"^:","instaparse.gll/merge-meta"]],"~i31",[["^ ","^Y",33,"^Z",13,"^:","obj"]],"~i35",[["^ ","^Y",37,"^Z",13,"^:","metamap"]]],"^19",["^ ","~i4",[["^ ","^Y",0,"^Z",15,"^:","obj"]]],"~i17",["^ ","~i0",[["^ ","^Y",0,"^Z",18],["^ ","^Y",40,"^Z",18],["^ ","^Y",0,"^Z",19]],"~i7",[["^ ","^Y",0,"^Z",18,"^:","instaparse.transform/enlive-transform"]]],"^13",["^ ","~i3",[["^ ","^Y",88,"^Z",18,"^:","transform-map"]],"^1=",[["^ ","^Y",102,"^Z",18,"^:","parse-tree"]]],"~i19",["^ ","~i2",[["^ ","^Y",0,"^Z",19],["^ ","^Y",0,"^Z",22]],"~i8",[["^ ","^Y",4,"^Z",19,"^:","transform"]],"^13",[["^ ","^Y",16,"^Z",19],["^ ","^Y",33,"^Z",19,"^:","G__30997"],["^ ","^Y",0,"^Z",20],["^ ","^Y",0,"^Z",20],["^ ","^Y",98,"^Z",20,"^:","G__30997"],["^ ","^Y",134,"^Z",20,"^:","G__30997"]],"^1>",[["^ ","^Y",8,"^Z",20,"^:","transform-map"],["^ ","^Y",54,"^Z",20,"^:","transform-map"],["^ ","^Y",110,"^Z",20,"^:","transform-map"]],"~i33",[["^ ","^Y",44,"^Z",19],["^ ","^Y",44,"^Z",19]],"~i39",[["^ ","^Y",126,"^Z",19,"^:","parse-tree"]]],"^14",["^ ","~i4",[["^ ","^Y",0,"^Z",22],["^ ","^Y",0,"^Z",25],["^ ","^Y",0,"^Z",28]]],"~i21",["^ ","~i6",[["^ ","^Y",20,"^Z",22,"^:","transform"]]],"~i22",["^ ","~i6",[["^ ","^Y",0,"^Z",23]],"~i7",[["^ ","^Y",7,"^Z",23,"^:","instaparse.transform/merge-meta"]]],"^15",["^ ","~i8",[["^ ","^Y",39,"^Z",23]],"~i9",[["^ ","^Y",39,"^Z",23,"^:","cljs.core.apply.cljs$core$IFn$_invoke$arity$2"]],"^19",[["^ ","^Y",85,"^Z",23,"^:","transform"]],"~i25",[["^ ","^Y",95,"^Z",23]],"~i26",[["^ ","^Y",95,"^Z",23,"^:","cljs.core.map.cljs$core$IFn$_invoke$arity$2"]],"~i30",[["^ ","^Y",139,"^Z",23]],"^1;",[["^ ","^Y",139,"^Z",23,"^:","cljs.core.partial.cljs$core$IFn$_invoke$arity$2"]],"^1@",[["^ ","^Y",187,"^Z",23,"^:","instaparse.transform/enlive-transform"]],"~i56",[["^ ","^Y",225,"^Z",23,"^:","transform-map"]]],"^16",["^ ","^1E",[["^ ","^Y",240,"^Z",23],["^ ","^Y",240,"^Z",23]],"~i40",[["^ ","^Y",327,"^Z",23,"^:","parse-tree"]]],"^1C",["^ ","~i8",[["^ ","^Y",341,"^Z",23]],"~i9",[["^ ","^Y",341,"^Z",23,"^:","cljs.core/meta"]],"^12",[["^ ","^Y",356,"^Z",23,"^:","parse-tree"]]],"^1D",["^ ","~i6",[["^ ","^Y",20,"^Z",25],["^ ","^Y",20,"^Z",25]],"^18",[["^ ","^Y",102,"^Z",25,"^:","parse-tree"]]],"^[",["^ ","~i6",[["^ ","^Y",0,"^Z",26],["^ ","^Y",64,"^Z",26]],"~i7",[["^ ","^Y",7,"^Z",26,"^:","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3"]],"^11",[["^ ","^Y",53,"^Z",26,"^:","parse-tree"]],"^1?",[["^ ","^Y",121,"^Z",26]],"~i34",[["^ ","^Y",121,"^Z",26,"^:","cljs.core.map.cljs$core$IFn$_invoke$arity$2"]],"~i38",[["^ ","^Y",165,"^Z",26]],"^1@",[["^ ","^Y",165,"^Z",26,"^:","cljs.core.partial.cljs$core$IFn$_invoke$arity$2"]],"~i47",[["^ ","^Y",213,"^Z",26,"^:","instaparse.transform/enlive-transform"]],"~i64",[["^ ","^Y",251,"^Z",26,"^:","transform-map"]]],"~i28",["^ ","^1I",[["^ ","^Y",266,"^Z",26],["^ ","^Y",266,"^Z",26]],"~i48",[["^ ","^Y",353,"^Z",26,"^:","parse-tree"]]],"^1E",["^ ","~i6",[["^ ","^Y",0,"^Z",28,"^:","parse-tree"]]],"~i32",["^ ","~i0",[["^ ","^Y",0,"^Z",33],["^ ","^Y",40,"^Z",33],["^ ","^Y",0,"^Z",34]],"~i7",[["^ ","^Y",0,"^Z",33,"^:","instaparse.transform/hiccup-transform"]]],"^1?",["^ ","~i3",[["^ ","^Y",88,"^Z",33,"^:","transform-map"]],"^1=",[["^ ","^Y",102,"^Z",33,"^:","parse-tree"]]],"^1H",["^ ","~i2",[["^ ","^Y",0,"^Z",34]],"~i6",[["^ ","^Y",3,"^Z",34]],"^17",[["^ ","^Y",4,"^Z",34]],"^18",[["^ ","^Y",4,"^Z",34,"^:","cljs.core/sequential?"]],"^16",[["^ ","^Y",32,"^Z",34,"^:","parse-tree"]],"~i36",[["^ ","^Y",49,"^Z",34]],"^1:",[["^ ","^Y",49,"^Z",34,"^:","cljs.core/seq"]],"~i41",[["^ ","^Y",63,"^Z",34,"^:","parse-tree"]]],"^1<",["^ ","~i4",[["^ ","^Y",0,"^Z",35],["^ ","^Y",4,"^Z",35,"^:","temp__5455__auto__"],["^ ","^Y",0,"^Z",38],["^ ","^Y",0,"^Z",38],["^ ","^Y",20,"^Z",38,"^:","temp__5455__auto__"],["^ ","^Y",0,"^Z",39],["^ ","^Y",16,"^Z",39,"^:","temp__5455__auto__"],["^ ","^Y",0,"^Z",40]],"^11",[["^ ","^Y",4,"^Z",39,"^:","transform"]],"^15",[["^ ","^Y",25,"^Z",35],["^ ","^Y",42,"^Z",35,"^:","G__30998"],["^ ","^Y",0,"^Z",36],["^ ","^Y",0,"^Z",36],["^ ","^Y",98,"^Z",36,"^:","G__30998"],["^ ","^Y",134,"^Z",36,"^:","G__30998"]],"^16",[["^ ","^Y",8,"^Z",36,"^:","transform-map"],["^ ","^Y",54,"^Z",36,"^:","transform-map"],["^ ","^Y",110,"^Z",36,"^:","transform-map"]],"^1I",[["^ ","^Y",53,"^Z",35]],"^1@",[["^ ","^Y",53,"^Z",35,"^:","cljs.core/first"]],"~i45",[["^ ","^Y",69,"^Z",35,"^:","parse-tree"]]],"^1O",["^ ","~i6",[["^ ","^Y",0,"^Z",40]],"~i7",[["^ ","^Y",7,"^Z",40,"^:","instaparse.transform/merge-meta"]]],"^1:",["^ ","~i8",[["^ ","^Y",39,"^Z",40]],"~i9",[["^ ","^Y",39,"^Z",40,"^:","cljs.core.apply.cljs$core$IFn$_invoke$arity$2"]],"^19",[["^ ","^Y",85,"^Z",40,"^:","transform"]],"^1C",[["^ ","^Y",95,"^Z",40]],"^1D",[["^ ","^Y",95,"^Z",40,"^:","cljs.core.map.cljs$core$IFn$_invoke$arity$2"]],"^1E",[["^ ","^Y",139,"^Z",40]],"^1;",[["^ ","^Y",139,"^Z",40,"^:","cljs.core.partial.cljs$core$IFn$_invoke$arity$2"]],"^1@",[["^ ","^Y",187,"^Z",40,"^:","instaparse.transform/hiccup-transform"]],"^1F",[["^ ","^Y",225,"^Z",40,"^:","transform-map"]]],"^1I",["^ ","^1E",[["^ ","^Y",240,"^Z",40]],"^1;",[["^ ","^Y",240,"^Z",40,"^:","cljs.core/next"]],"^1O",[["^ ","^Y",255,"^Z",40,"^:","parse-tree"]]],"^1@",["^ ","~i8",[["^ ","^Y",269,"^Z",40]],"~i9",[["^ ","^Y",269,"^Z",40,"^:","cljs.core/meta"]],"^12",[["^ ","^Y",284,"^Z",40,"^:","parse-tree"]]],"^1G",["^ ","~i6",[["^ ","^Y",0,"^Z",42]],"~i7",[["^ ","^Y",7,"^Z",42,"^:","cljs.core/with-meta"]]],"^1P",["^ ","~i8",[["^ ","^Y",27,"^Z",42],["^ ","^Y",72,"^Z",42]],"~i9",[["^ ","^Y",27,"^Z",42,"^:","cljs.core.into.cljs$core$IFn$_invoke$arity$2"]],"^19",[["^ ","^Y",155,"^Z",42]],"~i16",[["^ ","^Y",155,"^Z",42,"^:","cljs.core/first"]],"^1B",[["^ ","^Y",171,"^Z",42,"^:","parse-tree"]]],"~i42",["^ ","^12",[["^ ","^Y",191,"^Z",42]],"^19",[["^ ","^Y",191,"^Z",42,"^:","cljs.core.map.cljs$core$IFn$_invoke$arity$2"]],"^1>",[["^ ","^Y",235,"^Z",42]],"^14",[["^ ","^Y",235,"^Z",42,"^:","cljs.core.partial.cljs$core$IFn$_invoke$arity$2"]],"^1L",[["^ ","^Y",283,"^Z",42,"^:","instaparse.transform/hiccup-transform"]],"^1Q",[["^ ","^Y",321,"^Z",42,"^:","transform-map"]]],"~i43",["^ ","^1>",[["^ ","^Y",336,"^Z",42]],"^14",[["^ ","^Y",336,"^Z",42,"^:","cljs.core/next"]],"^1C",[["^ ","^Y",351,"^Z",42,"^:","parse-tree"]]],"~i44",["^ ","~i8",[["^ ","^Y",365,"^Z",42]],"~i9",[["^ ","^Y",365,"^Z",42,"^:","cljs.core/meta"]],"^12",[["^ ","^Y",380,"^Z",42,"^:","parse-tree"]]],"^1Q",["^ ","~i4",[["^ ","^Y",0,"^Z",45,"^:","parse-tree"]]],"^1J",["^ ","~i0",[["^ ","^Y",0,"^Z",48],["^ ","^Y",33,"^Z",56],["^ ","^Y",0,"^Z",57]],"~i6",[["^ ","^Y",0,"^Z",56,"^:","instaparse.transform/transform"]]],"~i54",["^ ","~i3",[["^ ","^Y",74,"^Z",56,"^:","transform-map"]],"^1=",[["^ ","^Y",88,"^Z",56,"^:","parse-tree"]]],"^1F",["^ ","~i2",[["^ ","^Y",0,"^Z",57],["^ ","^Y",0,"^Z",60],["^ ","^Y",0,"^Z",69],["^ ","^Y",0,"^Z",72],["^ ","^Y",0,"^Z",75],["^ ","^Y",0,"^Z",78]]],"~i57",["^ ","~i4",[["^ ","^Y",3,"^Z",57]],"^11",[["^ ","^Y",10,"^Z",57,"^:","parse-tree"]]],"~i59",["^ ","~i4",[["^ ","^Y",0,"^Z",58,"^:","parse-tree"]]],"~i61",["^ ","~i4",[["^ ","^Y",20,"^Z",60],["^ ","^Y",37,"^Z",60,"^:","and__5114__auto__"],["^ ","^Y",0,"^Z",61],["^ ","^Y",0,"^Z",61],["^ ","^Y",3,"^Z",61,"^:","and__5114__auto__"],["^ ","^Y",0,"^Z",64,"^:","and__5114__auto__"]],"~i9",[["^ ","^Y",57,"^Z",60]],"~i10",[["^ ","^Y",57,"^Z",60,"^:","cljs.core/map?"]],"^19",[["^ ","^Y",78,"^Z",60,"^:","parse-tree"]],"^[",[["^ ","^Y",0,"^Z",62],["^ ","^Y",7,"^Z",62]],"^1?",[["^ ","^Y",89,"^Z",62,"^:","parse-tree"]]],"~i63",["^ ","~i4",[["^ ","^Y",0,"^Z",67]],"~i5",[["^ ","^Y",7,"^Z",67,"^:","instaparse.transform/enlive-transform"]],"^1B",[["^ ","^Y",45,"^Z",67,"^:","transform-map"]],"^1O",[["^ ","^Y",59,"^Z",67,"^:","parse-tree"]]],"~i65",["^ ","~i4",[["^ ","^Y",3,"^Z",69]],"~i9",[["^ ","^Y",4,"^Z",69]],"^1Z",[["^ ","^Y",4,"^Z",69,"^:","cljs.core/vector?"]],"^13",[["^ ","^Y",28,"^Z",69,"^:","parse-tree"]],"^1E",[["^ ","^Y",45,"^Z",69],["^ ","^Y",85,"^Z",69,"^:","cljs.core/Keyword"]],"^1G",[["^ ","^Y",46,"^Z",69]],"^1P",[["^ ","^Y",46,"^Z",69,"^:","cljs.core/first"]],"^1J",[["^ ","^Y",62,"^Z",69,"^:","parse-tree"]]],"~i67",["^ ","~i4",[["^ ","^Y",0,"^Z",70]],"~i5",[["^ ","^Y",7,"^Z",70,"^:","instaparse.transform/hiccup-transform"]],"^1B",[["^ ","^Y",45,"^Z",70,"^:","transform-map"]],"^1O",[["^ ","^Y",59,"^Z",70,"^:","parse-tree"]]],"~i69",["^ ","~i4",[["^ ","^Y",3,"^Z",72]],"~i5",[["^ ","^Y",3,"^Z",72,"^:","cljs.core/sequential?"]],"^1=",[["^ ","^Y",31,"^Z",72,"^:","parse-tree"]]],"~i72",["^ ","~i4",[["^ ","^Y",0,"^Z",73]],"~i5",[["^ ","^Y",7,"^Z",73,"^:","instaparse.transform/map-preserving-meta"]],"^1C",[["^ ","^Y",48,"^Z",73]],"^1D",[["^ ","^Y",48,"^Z",73,"^:","cljs.core.partial.cljs$core$IFn$_invoke$arity$2"]],"^1H",[["^ ","^Y",96,"^Z",73,"^:","instaparse.transform/transform"]],"^1U",[["^ ","^Y",127,"^Z",73,"^:","transform-map"]],"^1X",[["^ ","^Y",142,"^Z",73,"^:","parse-tree"]]],"~i74",["^ ","~i4",[["^ ","^Y",3,"^Z",75]],"^19",[["^ ","^Y",26,"^Z",75,"^:","instaparse/gll.Failure"]],"^1I",[["^ ","^Y",4,"^Z",75,"^:","parse-tree"]]],"~i76",["^ ","~i4",[["^ ","^Y",0,"^Z",76,"^:","parse-tree"]]],"~i79",["^ ","~i4",[["^ ","^Y",0,"^Z",78],["^ ","^Y",143,"^Z",78]],"~i5",[["^ ","^Y",7,"^Z",78,"^:","instaparse.util.throw_illegal_argument_exception.cljs$core$IFn$_invoke$arity$variadic"]]]],"~:cljc",true],"~:cache-keys",["~#cmap",[["^Q","instaparse/auto_flatten_seq.cljc"],1516731432000,["~:macro","^B"],1516731430000,["^Q","goog/math/math.js"],1516731431000,["^Q","instaparse/gll.cljc"],1516731432000,["^Q","goog/array/array.js"],1516731431000,["^Q","goog/debug/error.js"],1516731431000,["^Q","goog/dom/nodetype.js"],1516731431000,["^Q","instaparse/transform.cljc"],1516731432000,["^Q","goog/object/object.js"],1516731431000,"~:SHADOW-TIMESTAMP",1516731432000,["^Q","goog/math/long.js"],1516731431000,["^Q","instaparse/reduction.cljc"],1516731432000,["^Q","goog/i18n/uchar.js"],1516731431000,["^Q","goog/functions/functions.js"],1516731431000,["^Q","goog/structs/map.js"],1516731431000,["^Q","instaparse/failure.cljc"],1516731432000,["^Q","goog/asserts/asserts.js"],1516731431000,["^Q","goog/uri/uri.js"],1516731431000,["^Q","instaparse/print.cljc"],1516731432000,["^2:","^@"],1516731432000,["^Q","goog/base.js"],1516731431000,["^Q","goog/structs/structs.js"],1516731431000,["^Q","clojure/string.cljs"],1516731430000,["^Q","goog/string/string.js"],1516731431000,["^Q","goog/reflect/reflect.js"],1516731431000,["^Q","goog/string/stringbuffer.js"],1516731431000,["^Q","goog/iter/iter.js"],1516731431000,["^Q","cljs/core.cljs"],1516731430000,["^Q","instaparse/util.cljc"],1516731432000,["^Q","goog/math/integer.js"],1516731431000,["^Q","goog/uri/utils.js"],1516731431000,["^Q","instaparse/combinators_source.cljc"],1516731432000]],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","Functions to transform parse trees"],"^7",null,"^8",["^9",[]],"^:","^;","^>",null,"^?",["^ ","^@","^@","^A","^A","^B","^B","^C","^C"],"^D",["^9",["^E"]],"^F",["^ ","^G","^A"],"~:defs",["^ ","~$map-preserving-meta",["^ ","~:protocol-inline",null,"^5",["^ ","~:file","instaparse/transform.cljc","~:line",6,"~:column",7,"~:end-line",6,"~:end-column",26,"~:arglists",["^J",["~$quote",["^J",[["~$f","~$l"]]]]]],"^:","~$instaparse.transform/map-preserving-meta","~:variadic",false,"^2@","instaparse/transform.cljc","^2D",26,"~:method-params",["^J",[["~$f","~$l"]]],"~:protocol-impl",null,"~:arglists-meta",["^J",[null,null]],"^2B",1,"^2A",6,"^2C",6,"~:max-fixed-arity",2,"~:fn-var",true,"^2E",["^J",["^2F",["^J",[["~$f","~$l"]]]]]],"~$merge-meta",["^ ","^2?",null,"^5",["^ ","^2@","instaparse/transform.cljc","^2A",9,"^2B",7,"^2C",9,"^2D",17,"^2E",["^J",["^2F",["^J",[["~$obj","~$metamap"]]]]],"^6","This variation of the merge-meta in gll does nothing if obj is not\nsomething that can have a metamap attached."],"^:","~$instaparse.transform/merge-meta","^2H",false,"^2@","instaparse/transform.cljc","^2D",17,"^2I",["^J",[["^2O","^2P"]]],"^2J",null,"^2K",["^J",[null,null]],"^2B",1,"^2A",9,"^2C",9,"^2L",2,"^2M",true,"^2E",["^J",["^2F",["^J",[["^2O","^2P"]]]]],"^6","This variation of the merge-meta in gll does nothing if obj is not\nsomething that can have a metamap attached."],"~$enlive-transform",["^ ","^2?",null,"^5",["^ ","^2@","instaparse/transform.cljc","^2A",18,"^2B",8,"^2C",18,"^2D",24,"~:private",true,"^2E",["^J",["^2F",["^J",[["~$transform-map","~$parse-tree"]]]]]],"^2S",true,"^:","~$instaparse.transform/enlive-transform","^2H",false,"^2@","instaparse/transform.cljc","^2D",24,"^2I",["^J",[["^2T","^2U"]]],"^2J",null,"^2K",["^J",[null,null]],"^2B",1,"^2A",18,"^2C",18,"^2L",2,"^2M",true,"^2E",["^J",["^2F",["^J",[["^2T","^2U"]]]]]],"~$hiccup-transform",["^ ","^2?",null,"^5",["^ ","^2@","instaparse/transform.cljc","^2A",33,"^2B",8,"^2C",33,"^2D",24,"^2S",true,"^2E",["^J",["^2F",["^J",[["^2T","^2U"]]]]]],"^2S",true,"^:","~$instaparse.transform/hiccup-transform","^2H",false,"^2@","instaparse/transform.cljc","^2D",24,"^2I",["^J",[["^2T","^2U"]]],"^2J",null,"^2K",["^J",[null,null]],"^2B",1,"^2A",33,"^2C",33,"^2L",2,"^2M",true,"^2E",["^J",["^2F",["^J",[["^2T","^2U"]]]]]],"~$transform",["^ ","^2?",null,"^5",["^ ","^2@","instaparse/transform.cljc","^2A",48,"^2B",7,"^2C",48,"^2D",16,"^2E",["^J",["^2F",["^J",[["^2T","^2U"]]]]],"^6","Takes a transform map and a parse tree (or seq of parse-trees).\n   A transform map is a mapping from tags to \n   functions that take a node's contents and return\n   a replacement for the node, i.e.,\n   {:node-tag (fn [child1 child2 ...] node-replacement),\n    :another-node-tag (fn [child1 child2 ...] node-replacement)}"],"^:","~$instaparse.transform/transform","^2H",false,"^2@","instaparse/transform.cljc","^2D",16,"^2I",["^J",[["^2T","^2U"]]],"^2J",null,"^2K",["^J",[null,null]],"^2B",1,"^2A",48,"^2C",48,"^2L",2,"^2M",true,"^2E",["^J",["^2F",["^J",[["^2T","^2U"]]]]],"^6","Takes a transform map and a parse tree (or seq of parse-trees).\n   A transform map is a mapping from tags to \n   functions that take a node's contents and return\n   a replacement for the node, i.e.,\n   {:node-tag (fn [child1 child2 ...] node-replacement),\n    :another-node-tag (fn [child1 child2 ...] node-replacement)}"]],"^H",["^ ","^B","^B","^@","^@"],"~:cljs.analyzer/constants",["^ ","^D",["^9",["~:else","~:content","~:tag"]],"~:order",["^32","^31","^30"]],"^M",["^ ","^E",["^9",[]]],"^N",["^ "],"^O",["^C","^B","^@","^A"]],"^=","^;","~:ns-specs",["^ "],"~:ns-speced-vars",[],"~:compiler-options",["^29",[["^36","~:static-fns"],true,["^36","~:elide-asserts"],false,["^36","~:optimize-constants"],null,["^36","~:emit-constants"],null,["^36","~:infer-externs"],true,["^36","^V"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^36","~:fn-invoke-direct"],null,["^36","^X"],"/dev/null"]]]