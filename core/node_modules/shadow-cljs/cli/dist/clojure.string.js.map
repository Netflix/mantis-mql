{"version":3,"file":"clojure.string.js","sources":["clojure/string.cljs"],"mappings":"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","names":["goog.string/startsWith","s","substr","clojure.string/discard-trailing-if-needed","var_args","G__30458","clojure.string/join","js/Error","G__30480","clojure.string/index-of","sb","goog/string.StringBuffer","coll","cljs.core/seq","clojure.string.split.cljs$core$IFn$_invoke$arity$2","index","ch","cljs.core.get.cljs$core$IFn$_invoke$arity$2","value","from-index","cljs.core/str","cljs.core.map.cljs$core$IFn$_invoke$arity$2","cljs.core/vec","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","cljs.core/cons","limit","goog.string/contains","buffer","m","cljs.core/re-find","re","replacement","match","clojure.string/reverse","cmap","c","cljs.core.subvec.cljs$core$IFn$_invoke$arity$3","cljs.core.subs.cljs$core$IFn$_invoke$arity$2","separator","result","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core/count","matches","goog.string/isEmptySafe","G__30483","clojure.string/last-index-of","v","clojure.string/trimr","js/RegExp","clojure.string.split.cljs$core$IFn$_invoke$arity$3","G__30469","clojure.string/split","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","cljs.core/conj","clojure.string/ends-with?","parts","clojure.string/capitalize","G__30451","goog.string/trimLeft","clojure.string/includes?","G__30452","f","cljs.core/first","cljs.core/peek","clojure.string/trim-newline","clojure.string/replace-all","r","clojure.string/seq-reverse","G__30453","cljs.core/pop","clojure.string/upper-case","pred__30465","expr__30466","cljs.core/==","clojure.string/replace","clojure.string/replace-first","goog.string/capitalize","clojure.string/trim","clojure.string/re-surrogate-pair","clojure.string/replace-with","clojure.string/split-with-empty-regex","cljs.core/next","goog.string/trimRight","goog.string/endsWith","cljs.core/PersistentVector","cljs.core.drop_last.cljs$core$IFn$_invoke$arity$2","args","clojure.string/pop-last-while-empty","clojure.string/triml","goog.string/trim","length","clojure.string/blank?","goog.string/regExpEscape","clojure.string/split-lines","clojure.string/escape","clojure.string/lower-case","clojure.string/starts-with?"],"sourcesContent":[";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns clojure.string\n  (:refer-clojure :exclude [replace reverse])\n  (:require [goog.string :as gstring])\n  (:import [goog.string StringBuffer]))\n\n(defn- seq-reverse\n  [coll]\n  (reduce conj () coll))\n\n(def ^:private re-surrogate-pair\n  (js/RegExp. \"([\\\\uD800-\\\\uDBFF])([\\\\uDC00-\\\\uDFFF])\" \"g\"))\n\n(defn reverse\n  \"Returns s with its characters reversed.\"\n  [s]\n  (-> (.replace s re-surrogate-pair \"$2$1\")\n      (.. (split \"\") (reverse) (join \"\"))))\n\n(defn- replace-all\n  [s re replacement]\n  (let [r (js/RegExp. (.-source re)\n                      (cond-> \"g\"\n                        (.-ignoreCase re) (str \"i\")\n                        (.-multiline re) (str \"m\")\n                        (.-unicode re) (str \"u\")))]\n    (.replace s r replacement)))\n\n(defn- replace-with\n  [f]\n  (fn [& args]\n    (let [matches (drop-last 2 args)]\n      (if (= (count matches) 1)\n        (f (first matches))\n        (f (vec matches))))))\n\n(defn replace\n  \"Replaces all instance of match with replacement in s.\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).\"\n  [s match replacement]\n  (cond\n    (string? match)\n    (.replace s (js/RegExp. (gstring/regExpEscape match) \"g\") replacement)\n\n    (instance? js/RegExp match)\n    (if (string? replacement)\n      (replace-all s match replacement)\n      (replace-all s match (replace-with replacement)))\n\n    :else (throw (str \"Invalid match arg: \" match))))\n\n(defn replace-first\n  \"Replaces the first instance of match with replacement in s.\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).\"\n  [s match replacement]\n  (.replace s match replacement))\n\n(defn join\n  \"Returns a string of all elements in coll, as returned by (seq coll),\n  separated by an optional separator.\"\n  ([coll]\n   (loop [sb (StringBuffer.) coll (seq coll)]\n     (if-not (nil? coll)\n       (recur (. sb (append (str (first coll)))) (next coll))\n       (.toString sb))))\n  ([separator coll]\n   (loop [sb (StringBuffer.) coll (seq coll)]\n     (if-not (nil? coll)\n       (do\n         (. sb (append (str (first coll))))\n         (let [coll (next coll)]\n           (when-not (nil? coll)\n             (. sb (append separator)))\n           (recur sb coll)))\n       (.toString sb)))))\n\n(defn upper-case\n  \"Converts string to all upper-case.\"\n  [s]\n  (.toUpperCase s))\n\n(defn lower-case\n  \"Converts string to all lower-case.\"\n  [s]\n  (.toLowerCase s))\n\n(defn capitalize\n  \"Converts first character of the string to upper-case, all other\n  characters to lower-case.\"\n  [s]\n  (gstring/capitalize s))\n\n;; The JavaScript split function takes a limit argument but the return\n;; value is not the same as the Java split function.\n;;\n;; Java: (.split \"a-b-c\" #\"-\" 2) => [\"a\" \"b-c\"]\n;; JavaScript: (.split \"a-b-c\" #\"-\" 2) => [\"a\" \"b\"]\n;;\n;; For consistency, the three arg version has been implemented to\n;; mimic Java's behavior.\n\n(defn- pop-last-while-empty\n  [v]\n  (loop [v v]\n    (if (identical? \"\" (peek v))\n      (recur (pop v))\n      v)))\n\n(defn- discard-trailing-if-needed\n  [limit v]\n  (if (and (== 0 limit) (< 1 (count v)))\n    (pop-last-while-empty v)\n    v))\n\n(defn- split-with-empty-regex\n  [s limit]\n  (if (or (<= limit 0) (>= limit (+ 2 (count s))))\n    (conj (vec (cons \"\" (map str (seq s)))) \"\")\n    (condp == limit\n      1 (vector s)\n      2 (vector \"\" s)\n      (let [c (- limit 2)]\n        (conj (vec (cons \"\" (subvec (vec (map str (seq s))) 0 c))) (subs s c))))))\n\n(defn split\n  \"Splits string on a regular expression. Optional argument limit is\n  the maximum number of splits. Not lazy. Returns vector of the splits.\"\n  ([s re]\n     (split s re 0))\n    ([s re limit]\n     (discard-trailing-if-needed limit\n       (if (identical? \"/(?:)/\" (str re))\n         (split-with-empty-regex s limit)\n         (if (< limit 1)\n           (vec (.split (str s) re))\n           (loop [s s\n                  limit limit\n                  parts []]\n             (if (== 1 limit)\n               (conj parts s)\n               (let [m (re-find re s)]\n                 (if-not (nil? m)\n                   (let [index (.indexOf s m)]\n                     (recur (.substring s (+ index (count m)))\n                       (dec limit)\n                       (conj parts (.substring s 0 index))))\n                   (conj parts s))))))))))\n\n(defn split-lines\n  \"Splits s on \\n or \\r\\n.\"\n  [s]\n  (split s #\"\\n|\\r\\n\"))\n\n(defn trim\n  \"Removes whitespace from both ends of string.\"\n  [s]\n  (gstring/trim s))\n\n(defn triml\n  \"Removes whitespace from the left side of string.\"\n  [s]\n  (gstring/trimLeft s))\n\n(defn trimr\n  \"Removes whitespace from the right side of string.\"\n  [s]\n  (gstring/trimRight s))\n\n(defn trim-newline\n  \"Removes all trailing newline \\\\n or return \\\\r characters from\n  string.  Similar to Perl's chomp.\"\n  [s]\n  (loop [index (.-length s)]\n    (if (zero? index)\n      \"\"\n      (let [ch (get s (dec index))]\n        (if (or (identical? \\newline ch)\n                (identical? \\return ch))\n          (recur (dec index))\n          (.substring s 0 index))))))\n\n(defn ^boolean blank?\n  \"True is s is nil, empty, or contains only whitespace.\"\n  [s]\n  (gstring/isEmptySafe s))\n\n(defn escape\n  \"Return a new string, using cmap to escape each character ch\n   from s as follows:\n\n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.\"\n  [s cmap]\n  (let [buffer (StringBuffer.)\n        length (.-length s)]\n    (loop [index 0]\n      (if (== length index)\n        (. buffer (toString))\n        (let [ch (.charAt s index)\n              replacement (get cmap ch)]\n          (if-not (nil? replacement)\n            (.append buffer (str replacement))\n            (.append buffer ch))\n          (recur (inc index)))))))\n\n(defn index-of\n  \"Return index of value (string or char) in s, optionally searching\n  forward from from-index or nil if not found.\"\n  ([s value]\n   (let [result (.indexOf s value)]\n     (if (neg? result)\n       nil\n       result)))\n  ([s value from-index]\n   (let [result (.indexOf s value from-index)]\n     (if (neg? result)\n       nil\n       result))))\n\n(defn last-index-of\n  \"Return last index of value (string or char) in s, optionally\n  searching backward from from-index or nil if not found.\"\n  ([s value]\n   (let [result (.lastIndexOf s value)]\n     (if (neg? result)\n       nil\n       result)))\n  ([s value from-index]\n   (let [result (.lastIndexOf s value from-index)]\n     (if (neg? result)\n       nil\n       result))))\n\n(defn ^boolean starts-with?\n  \"True if s starts with substr.\"\n  [s substr]\n  (gstring/startsWith s substr))\n\n(defn ^boolean ends-with?\n  \"True if s ends with substr.\"\n  [s substr]\n  (gstring/endsWith s substr))\n\n(defn ^boolean includes?\n  \"True if s includes substr.\"\n  [s substr]\n  (gstring/contains s substr))\n"]}