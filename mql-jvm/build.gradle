configurations {
    shadedAndRelocatedConfiguration
    implementation.extendsFrom shadedAndRelocatedConfiguration
}

repositories { 
  mavenCentral()
  maven { url "https://clojars.org/repo" }
}

compileTestJava {
    options.compilerArgs << "-Xlint:unchecked" << "-Xlint:deprecation"
}

dependencies {
  // Clojure 1.10+ is required for Java 9+ compatibility (gvec.clj toArray issue)
  shadedAndRelocatedConfiguration 'org.clojure:clojure:1.10.3'
  shadedAndRelocatedConfiguration 'org.clojure:data.json:0.2.3'
  shadedAndRelocatedConfiguration 'instaparse:instaparse:1.4.9'
  shadedAndRelocatedConfiguration 'io.reactivex:rxjava:1.3.8'
  // rxclojure must also be shaded because it uses clojure.* classes
  shadedAndRelocatedConfiguration 'io.reactivex:rxclojure:1.0.0'
  testImplementation 'criterium:criterium:0.4.4'
  testImplementation 'org.clojure:test.check:0.9.0'
  testImplementation 'junit:junit:4.12'
  testImplementation 'org.assertj:assertj-core:3.12.2'
  testImplementation 'com.fasterxml.jackson.module:jackson-module-afterburner:2.9.9'
  testImplementation 'com.fasterxml.jackson.dataformat:jackson-dataformat-cbor:2.9.9'
  testImplementation 'com.fasterxml.jackson.core:jackson-core:2.9.9'
  testImplementation 'com.fasterxml.jackson.core:jackson-databind:2.9.9'
  testImplementation 'com.fasterxml.jackson.core:jackson-annotations:2.9.9'
}

// Disable for gradle 7.x compatibility with netflixoss
//gradle.startParameter.excludedTaskNames += "licenseMain"
//gradle.startParameter.excludedTaskNames += "licenseTest"

import com.github.jengelman.gradle.plugins.shadow.transformers.Transformer
import com.github.jengelman.gradle.plugins.shadow.transformers.TransformerContext
import shadow.org.apache.tools.zip.ZipOutputStream
import shadow.org.apache.tools.zip.ZipEntry
import org.gradle.api.file.FileTreeElement
import org.objectweb.asm.*


/**
 * Custom transformer that rewrites .clj/.cljc source file CONTENTS during shading.
 * 
 * This is required because shadowJar's relocate only transforms:
 *   - .class file bytecode references
 *   - Resource paths (file locations)
 * 
 * But it does NOT transform the actual text content inside .clj source files.
 * Clojure loads and compiles .clj source files at runtime, and these files 
 * contain hardcoded namespace references like (in-ns 'clojure.core) and 
 * (import ...) that must match the relocated package structure.
 */
class ClojureSourceRelocateTransformer implements Transformer {
    private Map<String, String> relocations = [:]
    private Map<String, byte[]> transformedFiles = [:]

    void relocate(String pattern, String destination) {
        relocations[pattern] = destination
    }

    @Override
    boolean canTransformResource(FileTreeElement element) {
        def path = element.relativePath.pathString
        return path.endsWith('.clj') || path.endsWith('.cljc')
    }

    @Override
    void transform(TransformerContext context) {
        def path = context.path
        def content = context.is.getText('UTF-8')

        // Apply all relocations to the source content
        // Order matters: do more specific patterns first (rx.lang.clojure before clojure)
        // This prevents double-shading (e.g., clojure within io.mantisrx.mql.shaded.rx.lang.clojure)
        def sortedRelocations = relocations.sort { a, b -> b.key.length() <=> a.key.length() }
        
        // Use a placeholder approach to prevent double-replacement
        // First pass: replace with unique placeholders
        def dotPlaceholders = [:]  // For dot-notation patterns
        def slashPlaceholders = [:] // For slash-notation patterns (resource paths)
        int idx = 0
        sortedRelocations.each { pattern, destination ->
            def dotPlaceholder = "##SHADE_DOT_${idx}##"
            def slashPlaceholder = "##SHADE_SLASH_${idx}##"
            def slashPattern = pattern.replace('.', '/')
            def slashDestination = destination.replace('.', '/')
            
            dotPlaceholders[dotPlaceholder] = destination
            slashPlaceholders[slashPlaceholder] = slashDestination
            
            // Replace namespace references (dot notation): clojure.core -> placeholder.core
            content = content.replace(pattern + '.', dotPlaceholder + '.')
            // Replace path references (slash notation): clojure/core -> placeholder/core  
            content = content.replace(slashPattern + '/', slashPlaceholder + '/')
            // Replace quoted symbols: 'clojure.core -> 'placeholder.core
            content = content.replace("'" + pattern, "'" + dotPlaceholder)
            
            idx++
        }
        
        // Second pass: replace placeholders with actual shaded names
        dotPlaceholders.each { placeholder, destination ->
            content = content.replace(placeholder, destination)
        }
        slashPlaceholders.each { placeholder, destination ->
            content = content.replace(placeholder, destination)
        }

        transformedFiles[path] = content.getBytes('UTF-8')
    }

    @Override
    boolean hasTransformedResource() {
        return !transformedFiles.isEmpty()
    }

    @Override
    void modifyOutputStream(ZipOutputStream os, boolean preserveFileTimestamps) {
        transformedFiles.each { path, bytes ->
            def zipEntry = new ZipEntry(path)
            os.putNextEntry(zipEntry)
            os.write(bytes)
            os.closeEntry()
        }
        transformedFiles.clear()
    }
}

shadowJar {
    classifier null // this configuration is used to produce only the shadowed jar
    
    // Apply relocations to bytecode (.class files) and resource paths
    relocate 'instaparse', 'io.mantisrx.mql.shaded.instaparse'
    relocate 'clojure', 'io.mantisrx.mql.shaded.clojure'
    relocate 'rx.lang.clojure', 'io.mantisrx.mql.shaded.rx.lang.clojure'
    
    // Also transform .clj/.cljc source file CONTENTS with the same relocations
    def clojureTransformer = new ClojureSourceRelocateTransformer()
    clojureTransformer.relocate('instaparse', 'io.mantisrx.mql.shaded.instaparse')
    clojureTransformer.relocate('clojure', 'io.mantisrx.mql.shaded.clojure')
    clojureTransformer.relocate('rx.lang.clojure', 'io.mantisrx.mql.shaded.rx.lang.clojure')
    transform(clojureTransformer)
    
    configurations = [project.configurations.shadedAndRelocatedConfiguration] // shadowJar should only bundle dependencies on this configuration
}

// Post-process the shadow JAR to fix string constants that shadowJar's relocate doesn't catch.
// These are method descriptor strings like "void <init>(clojure.lang.Keyword)" used by
// Clojure's compiler (via ASM's Method.getMethod()) for dynamic bytecode generation.
// We use ASM to properly rewrite these strings without corrupting the class file structure.
task fixClojureStringConstants {
    dependsOn shadowJar
    doLast {
        def jarFile = shadowJar.archiveFile.get().asFile
        def tempDir = file("${buildDir}/tmp/fixClojureStrings")
        tempDir.deleteDir()
        tempDir.mkdirs()
        
        // Extract the jar
        ant.unzip(src: jarFile, dest: tempDir)
        
        def shadedPrefix = 'io.mantisrx.mql.shaded.'
        
        // Helper to safely transform a string only if it contains unshaded patterns
        def transformString = { String str ->
            // Skip if empty or doesn't contain our target patterns
            if (!str || !str.contains('clojure.')) {
                return str
            }
            
            // Skip if the string already starts with or only contains shaded references
            // We only want to transform strings like "void <init>(clojure.lang.Keyword)"
            // where "clojure." appears WITHOUT being preceded by "shaded."
            
            // Use word boundary matching to find unshaded clojure references
            // Pattern: clojure.lang. NOT preceded by "shaded."
            def result = str
            
            // Only replace patterns that are NOT already shaded
            // Match: beginning of string OR non-letter/dot followed by clojure.
            result = result.replaceAll('(^|[^a-zA-Z.])clojure\\.lang\\.', '$1' + shadedPrefix + 'clojure.lang.')
            result = result.replaceAll('(^|[^a-zA-Z.])clojure\\.core\\.', '$1' + shadedPrefix + 'clojure.core.')
            result = result.replaceAll('(^|[^a-zA-Z.])clojure\\.asm\\.', '$1' + shadedPrefix + 'clojure.asm.')
            result = result.replaceAll('(^|[^a-zA-Z.])clojure\\.java\\.', '$1' + shadedPrefix + 'clojure.java.')
            result = result.replaceAll('(^|[^a-zA-Z.])clojure\\.spec\\.', '$1' + shadedPrefix + 'clojure.spec.')
            
            // Also handle closing paren patterns like "clojure.lang.Keyword)"
            result = result.replaceAll('(^|[^a-zA-Z.])clojure\\.lang\\)', '$1' + shadedPrefix + 'clojure.lang)')
            
            return result
        }
        
        // Process class files in the Clojure lang package (where Compiler lives)
        fileTree(tempDir).matching { 
            include 'io/mantisrx/mql/shaded/clojure/lang/*.class'
        }.each { classFile ->
            try {
                def bytes = classFile.bytes
                def reader = new ClassReader(bytes)
                def writer = new ClassWriter(0)
                
                def cv = new ClassVisitor(Opcodes.ASM9, writer) {
                    @Override
                    MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
                        def mv = super.visitMethod(access, name, descriptor, signature, exceptions)
                        return new MethodVisitor(Opcodes.ASM9, mv) {
                            @Override
                            void visitLdcInsn(Object value) {
                                if (value instanceof String) {
                                    super.visitLdcInsn(transformString((String) value))
                                } else {
                                    super.visitLdcInsn(value)
                                }
                            }
                        }
                    }
                }
                
                reader.accept(cv, 0)
                classFile.bytes = writer.toByteArray()
            } catch (Exception e) {
                println "Warning: Could not process ${classFile}: ${e.message}"
            }
        }
        
        // Repackage the jar
        jarFile.delete()
        ant.zip(destfile: jarFile, basedir: tempDir)
        
        // Cleanup
        tempDir.deleteDir()
    }
}

shadowJar.finalizedBy(fixClojureStringConstants)

// Verification task that tests the shaded JAR by loading it and calling the Clojure API
// This simulates how applications use the library
task verifyShadedJar {
    // Disabled by default - run with: ./gradlew :mql-jvm:verifyShadedJar -PenableVerify
    enabled = project.hasProperty('enableVerify')
    dependsOn fixClojureStringConstants
    doLast {
        def jarFile = shadowJar.archiveFile.get().asFile
        def jarUrl = jarFile.toURI().toURL()
        
        // Use the bootstrap classloader (null) as parent, and set context classloader
        def classLoader = new URLClassLoader([jarUrl] as URL[], ClassLoader.getSystemClassLoader())
        def originalContextCL = Thread.currentThread().getContextClassLoader()
        
        try {
            // Set context classloader so Clojure RT can find resources
            Thread.currentThread().setContextClassLoader(classLoader)
            
            // Load the shaded Clojure API
            def clojureClass = classLoader.loadClass('io.mantisrx.mql.shaded.clojure.java.api.Clojure')
            println "✓ Loaded shaded Clojure API class"
            
            // Get the var() method - Clojure 1.10+ uses Object params instead of String
            def varMethod = clojureClass.getMethod('var', Object.class, Object.class)
            def readMethod = clojureClass.getMethod('read', String.class)
            println "✓ Found Clojure.var() and Clojure.read() methods"
            
            // Get the require function from shaded clojure.core
            def requireFn = varMethod.invoke(null, 'io.mantisrx.mql.shaded.clojure.core', 'require')
            println "✓ Got require function from shaded clojure.core"
            
            // Require the MQL namespaces
            def ifnClass = classLoader.loadClass('io.mantisrx.mql.shaded.clojure.lang.IFn')
            def invokeMethod = ifnClass.getMethod('invoke', Object.class)
            
            def serverNs = readMethod.invoke(null, 'io.mantisrx.mql.jvm.interfaces.server')
            invokeMethod.invoke(requireFn, serverNs)
            println "✓ Required io.mantisrx.mql.jvm.interfaces.server namespace"
            
            def coreNs = readMethod.invoke(null, 'io.mantisrx.mql.jvm.interfaces.core')
            invokeMethod.invoke(requireFn, coreNs)
            println "✓ Required io.mantisrx.mql.jvm.interfaces.core namespace"
            
            // Get the make-query function
            def makeQueryFn = varMethod.invoke(null, 'io.mantisrx.mql.jvm.interfaces.server', 'make-query')
            println "✓ Got make-query function"
            
            // Create a query
            def invoke2Method = ifnClass.getMethod('invoke', Object.class, Object.class)
            def query = invoke2Method.invoke(makeQueryFn, 'test-sub', 'SELECT * WHERE true')
            println "✓ Created query successfully"
            
            // Verify it's a Query instance
            def queryClass = classLoader.loadClass('io.mantisrx.mql.jvm.core.Query')
            if (queryClass.isInstance(query)) {
                println "✓ Query is correct type"
            } else {
                throw new RuntimeException("Query is not the expected type")
            }
            
            println ""
            println "=========================================="
            println "✓ All shaded JAR verification tests passed!"
            println "=========================================="
            
        } finally {
            Thread.currentThread().setContextClassLoader(originalContextCL)
            classLoader.close()
        }
    }
}

// Run verification after fixing string constants
fixClojureStringConstants.finalizedBy(verifyShadedJar)


jar {
    enabled = false // this configuration is used to produce only the shadowed jar
}
jar.dependsOn shadowJar // this configuration is used to produce only the shadowed jar

afterEvaluate {
    publishing {
      publications {
        // to remove shaded dependency from ivy.xml
        withType(IvyPublication) {
          descriptor.withXml {
            asNode()
              .dependencies
              .dependency
              .findAll {
                ['clojure',
                 'data.json',
                 'instaparse',
                 'rxclojure'
                ].contains(it.artifactId.text())
              }
              .each { it.parent().remove(it) }
          }
        }
        // to remove shaded dependency from pom.xml
        withType(MavenPublication) {
          pom.withXml {
            asNode()
              .dependencies
              .dependency
              .findAll {
                ['clojure',
                 'data.json',
                 'instaparse',
                 'rxclojure'
                ].contains(it.artifactId.text())
              }
              .each { it.parent().remove(it) }
          }
        }
      }
    }
}
