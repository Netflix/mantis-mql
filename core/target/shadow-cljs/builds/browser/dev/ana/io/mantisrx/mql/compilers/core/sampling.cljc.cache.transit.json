["^ ","~:output",["^ ","~:js","goog.provide('io.mantisrx.mql.compilers.core.sampling');\ngoog.require('cljs.core');\ngoog.require('clojure.string');\nio.mantisrx.mql.compilers.core.sampling.abs = (function io$mantisrx$mql$compilers$core$sampling$abs(x){\nif((x < (0))){\nreturn (- x);\n} else {\nreturn x;\n}\n});\nio.mantisrx.mql.compilers.core.sampling.hasher = (function io$mantisrx$mql$compilers$core$sampling$hasher(x,salt){\nreturn io.mantisrx.mql.compilers.core.sampling.abs(cljs.core.hash([cljs.core.str.cljs$core$IFn$_invoke$arity$1(x),cljs.core.str.cljs$core$IFn$_invoke$arity$1(salt)].join('')));\n});\n/**\n * A tautology function of datum -> true.\n */\nio.mantisrx.mql.compilers.core.sampling.default_sampler = (function io$mantisrx$mql$compilers$core$sampling$default_sampler(datum){\nreturn true;\n});\n/**\n * Implementation for the random sampler, this specific implementation using\n * the hard coded 2^32 is to maintain ClojureScript compatibility. The design\n * has been ported from mantis-query (the old query language) to maintain\n * identical behavior. The random sampler is not deterministic, and consequently\n * not referentially transparent.\n * \n * factor: A uniform random number will be generated on the interval [0 factor).\n * threshold: datum is sampled if said uniform random number is below threshold.\n * datum: A map of String -> Object representing the data to be sampled.\n * \n * Sampling criteria:\n * x ~ uniform [0 factor)\n * x <= threshold\n * \n * 1% random sampling:  (random-sampler 100 10000)\n * 2% random sampling:  (random-sampler 200 10000)\n * 2% random sampling:  (random-sampler 100 5000)\n * 10% random sampling: (random-sampler 10 100)\n * 25% random sampling: (random-sampler 2500 10000)\n * \n * Returns true if the datum should be sampled, false otherwise.\n */\nio.mantisrx.mql.compilers.core.sampling.random_sampler = (function io$mantisrx$mql$compilers$core$sampling$random_sampler(factor,threshold,datum){\nreturn (cljs.core.mod(cljs.core.rand_int((2147483647)),factor) < threshold);\n});\n/**\n * A sticky sampler will 'stick' to certain values for the specified keys.\n * As an example if use esn as a key then esn=NFANDROID-FOO is sampled then\n * the stream will always sample data for which esn=NFANDROID-FOO. This is\n * determined using the hash of all the values concatenated as a string. Unlike\n * the random sampler the sticky sampler is is deterministic and referentially\n * transparent.\n * \n * This is useful in use cases such as sessionization in which we want to\n * process only a sample of the stream, but unlike random sampling we want\n * to ensure we see all data sampled matches the criteria.\n * \n * As with the random sampler the factor and threshold parameters can be used\n * to control the volume of data. See (doc random-sampler) for more details.\n * \n * ks: A seq of keys at the top level of datum used for stickiness.\n * salt: A salt value to be added to the hash of the key values.\n * factor: A uniform random number will be generated on the interval [0 factor)\n * threshold: datum is sampled if said uniform random number is below threshold.\n * datum: A map of String -> Object representing the data to be sampled.\n * \n * Returns true if the datum should be sampled, false otherwise.\n */\nio.mantisrx.mql.compilers.core.sampling.sticky_sampler = (function io$mantisrx$mql$compilers$core$sampling$sticky_sampler(ks,salt,factor,threshold,datum){\nvar str_to_hash = cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.str,cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__31573_SHARP_){\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(datum,p1__31573_SHARP_);\n}),ks));\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(str_to_hash,\"\")){\nreturn false;\n} else {\nif((cljs.core.mod(io.mantisrx.mql.compilers.core.sampling.hasher(str_to_hash,salt),factor) < threshold)){\nreturn true;\n} else {\nreturn false;\n\n}\n}\n});\n/**\n * A cross platform json parsing function which defers to host specific\n * parsers.\n * \n * string: A string representing valid JSON.\n * \n * Returns nested maps and vectors representing the parsed data.\n */\nio.mantisrx.mql.compilers.core.sampling.parse_json = (function io$mantisrx$mql$compilers$core$sampling$parse_json(string){\nreturn cljs.core.js__GT_clj.cljs$core$IFn$_invoke$arity$1(JSON.parse(string));\n});\nio.mantisrx.mql.compilers.core.sampling.default_factor = (10000);\nio.mantisrx.mql.compilers.core.sampling.sample_config__GT_extrapolation_factor = (function io$mantisrx$mql$compilers$core$sampling$sample_config__GT_extrapolation_factor(config){\nvar threshold = cljs.core.get.cljs$core$IFn$_invoke$arity$3(config,\"threshold\",io.mantisrx.mql.compilers.core.sampling.default_factor);\nvar factor = cljs.core.get.cljs$core$IFn$_invoke$arity$3(config,\"factor\",io.mantisrx.mql.compilers.core.sampling.default_factor);\nreturn (factor / threshold);\n});\nio.mantisrx.mql.compilers.core.sampling.extrapolatable_QMARK_ = (function io$mantisrx$mql$compilers$core$sampling$extrapolatable_QMARK_(x){\nreturn (clojure.string.starts_with_QMARK_(x,\"SUM(\")) || (clojure.string.starts_with_QMARK_(x,\"COUNT(\"));\n});\nio.mantisrx.mql.compilers.core.sampling.sample_config__GT_extrapolation_fn = (function io$mantisrx$mql$compilers$core$sampling$sample_config__GT_extrapolation_fn(raw_config){\nvar config = io.mantisrx.mql.compilers.core.sampling.parse_json(clojure.string.replace(raw_config,\"'\",\"\\\"\"));\nvar factor = io.mantisrx.mql.compilers.core.sampling.sample_config__GT_extrapolation_factor(config);\nif(cljs.core.truth_(cljs.core.get.cljs$core$IFn$_invoke$arity$3(config,\"extrapolate\",false))){\nreturn ((function (config,factor){\nreturn (function (datum){\nvar names = cljs.core.filter.cljs$core$IFn$_invoke$arity$2(io.mantisrx.mql.compilers.core.sampling.extrapolatable_QMARK_,cljs.core.keys(datum));\nreturn (new java.util.TreeMap(cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(cljs.core.merge,cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentArrayMap.EMPTY,datum)),cljs.core.map.cljs$core$IFn$_invoke$arity$2(((function (names,config,factor){\nreturn (function (name){\nreturn cljs.core.PersistentArrayMap.createAsIfByAssoc([name,(factor * cljs.core.get.cljs$core$IFn$_invoke$arity$2(datum,name))]);\n});})(names,config,factor))\n,names))));\n});\n;})(config,factor))\n} else {\nreturn cljs.core.identity;\n}\n});\n/**\n * Converts a json sampler configuration into a function which can then\n * be used to determine sampling eligibility by applying to data. Intended\n * for use with the filter function and behaves like a predicate.\n * \n * raw-config: A JSON string representing the configuration for the sampler.\n * This function will replace single quotes with double quotes first.\n * \n * Returns a function of datum -> boolean indicating eligibility for sampling\n * in which datum is a map of String -> Object.\n */\nio.mantisrx.mql.compilers.core.sampling.sample_config__GT_sampler = (function io$mantisrx$mql$compilers$core$sampling$sample_config__GT_sampler(raw_config){\nvar config = io.mantisrx.mql.compilers.core.sampling.parse_json(clojure.string.replace(raw_config,\"'\",\"\\\"\"));\nvar strategy = cljs.core.get.cljs$core$IFn$_invoke$arity$3(config,\"strategy\",new cljs.core.Keyword(null,\"default\",\"default\",-1987822328));\nvar threshold = cljs.core.get.cljs$core$IFn$_invoke$arity$3(config,\"threshold\",io.mantisrx.mql.compilers.core.sampling.default_factor);\nvar factor = cljs.core.get.cljs$core$IFn$_invoke$arity$3(config,\"factor\",io.mantisrx.mql.compilers.core.sampling.default_factor);\nvar ks = cljs.core.get.cljs$core$IFn$_invoke$arity$3(config,\"keys\",cljs.core.PersistentVector.EMPTY);\nvar salt = cljs.core.get.cljs$core$IFn$_invoke$arity$3(config,\"salt\",(0));\nvar extrapolate_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$3(config,\"extrapolate\",false);\nreturn new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"sample\",\"sample\",79023601),(((threshold >= factor))?io.mantisrx.mql.compilers.core.sampling.default_sampler:((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(strategy,\"RANDOM\"))?cljs.core.partial.cljs$core$IFn$_invoke$arity$3(io.mantisrx.mql.compilers.core.sampling.random_sampler,factor,threshold):((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(strategy,\"STICKY\"))?cljs.core.partial.cljs$core$IFn$_invoke$arity$variadic(io.mantisrx.mql.compilers.core.sampling.sticky_sampler,ks,salt,factor,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([threshold], 0)):io.mantisrx.mql.compilers.core.sampling.default_sampler\n))),new cljs.core.Keyword(null,\"extrapolation\",\"extrapolation\",1073945791),(cljs.core.truth_(extrapolate_QMARK_)?io.mantisrx.mql.compilers.core.sampling.sample_config__GT_extrapolation_fn(config):cljs.core.identity)], null);\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ "],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$io.mantisrx.mql.compilers.core.sampling","~:op","~:ns","~:imports",null,"~:requires",["^ ","~$clojure.string","^?","~$string","^?","~$cljs.core","^A","~$goog","^B"],"~:seen",["^8",["~:require"]],"~:uses",null,"~:require-macros",["^ ","^A","^A"],"~:form",["~#list",["~$ns","^:",["^H",["^D",["^?","~:as","^@"]]]]],"~:flags",["^ ","^D",["^8",[]]],"~:js-deps",["^ "],"~:deps",["^B","^A","^?"]],"^<","^:","~:resource-id",["~:shadow.build.classpath/resource","io/mantisrx/mql/compilers/core/sampling.cljc"],"~:compiled-at",1548711933684,"~:resource-name","io/mantisrx/mql/compilers/core/sampling.cljc","~:warnings",[],"~:source","(ns io.mantisrx.mql.compilers.core.sampling\n  (:require\n    [clojure.string :as string]\n    #?(:clj [clojure.data.json :as json])))\n\n(defn- abs\n  ^long [x]\n  (if (neg? x) (- x) x))\n\n(defn- hasher\n  ^long [^Object x ^long salt]\n  (abs (hash (str x salt))))\n\n(defn default-sampler\n  \"A tautology function of datum -> true.\"\n  [datum]\n  true)\n\n(defn random-sampler\n  \"Implementation for the random sampler, this specific implementation using\n   the hard coded 2^32 is to maintain ClojureScript compatibility. The design\n   has been ported from mantis-query (the old query language) to maintain\n   identical behavior. The random sampler is not deterministic, and consequently\n   not referentially transparent.\n\n   factor: A uniform random number will be generated on the interval [0 factor).\n   threshold: datum is sampled if said uniform random number is below threshold.\n   datum: A map of String -> Object representing the data to be sampled.\n\n   Sampling criteria:\n   x ~ uniform [0 factor)\n   x <= threshold\n\n   1% random sampling:  (random-sampler 100 10000)\n   2% random sampling:  (random-sampler 200 10000)\n   2% random sampling:  (random-sampler 100 5000)\n   10% random sampling: (random-sampler 10 100)\n   25% random sampling: (random-sampler 2500 10000)\n\n   Returns true if the datum should be sampled, false otherwise.\"\n  [factor threshold datum]\n  (< (mod (rand-int 2147483647) factor) threshold))\n\n(defn sticky-sampler\n  \"A sticky sampler will 'stick' to certain values for the specified keys.\n   As an example if use esn as a key then esn=NFANDROID-FOO is sampled then\n   the stream will always sample data for which esn=NFANDROID-FOO. This is\n   determined using the hash of all the values concatenated as a string. Unlike\n   the random sampler the sticky sampler is is deterministic and referentially\n   transparent.\n\n   This is useful in use cases such as sessionization in which we want to\n   process only a sample of the stream, but unlike random sampling we want\n   to ensure we see all data sampled matches the criteria.\n\n   As with the random sampler the factor and threshold parameters can be used\n   to control the volume of data. See (doc random-sampler) for more details.\n\n   ks: A seq of keys at the top level of datum used for stickiness.\n   salt: A salt value to be added to the hash of the key values.\n   factor: A uniform random number will be generated on the interval [0 factor)\n   threshold: datum is sampled if said uniform random number is below threshold.\n   datum: A map of String -> Object representing the data to be sampled.\n\n   Returns true if the datum should be sampled, false otherwise.\"\n  [ks salt factor threshold datum]\n  (let\n    [str-to-hash (apply str (map #(get datum %) ks))]\n    (cond\n      (= ^String str-to-hash \"\") false\n      (< (mod (hasher str-to-hash salt) factor) threshold) true\n      :else false)))\n\n(defn- parse-json\n  \"A cross platform json parsing function which defers to host specific\n   parsers.\n\n   string: A string representing valid JSON.\n\n   Returns nested maps and vectors representing the parsed data.\"\n  [string]\n  #?(:clj (json/read-str string)\n     :cljs (js->clj (.parse js/JSON string))))\n\n(def default-factor 10000)\n\n(defn sample-config->extrapolation-factor\n  [config]\n  (let\n    [threshold (get config \"threshold\" default-factor)\n     factor (get config \"factor\" default-factor)]\n    (double (/ factor threshold))))\n\n(defn- extrapolatable?\n  [x]\n  (or (string/starts-with? x \"SUM(\")\n      (string/starts-with? x \"COUNT(\")))\n\n(defn sample-config->extrapolation-fn\n  [raw-config]\n  (let [config (parse-json (clojure.string/replace raw-config \"'\" \"\\\"\"))\n        factor (sample-config->extrapolation-factor config)]\n    (if (get config \"extrapolate\" false)\n      (fn [datum]\n        (let\n          [names (filter extrapolatable? (keys datum))]\n          (java.util.TreeMap. \n            ^java.util.Map (apply (partial merge (into {} datum))\n                                  (map (fn [name] {name (* factor (get datum name))}) names)))))\n      identity)))\n\n\n(defn sample-config->sampler\n  \"Converts a json sampler configuration into a function which can then\n   be used to determine sampling eligibility by applying to data. Intended\n   for use with the filter function and behaves like a predicate.\n\n   raw-config: A JSON string representing the configuration for the sampler.\n   This function will replace single quotes with double quotes first.\n\n   Returns a function of datum -> boolean indicating eligibility for sampling\n   in which datum is a map of String -> Object.\"\n  [raw-config]\n  (let\n    [config (parse-json (clojure.string/replace raw-config \"'\" \"\\\"\"))\n     strategy (get config \"strategy\" :default)\n     threshold (get config \"threshold\" default-factor)\n     factor (get config \"factor\" default-factor)\n     ks (get config \"keys\" [])\n     salt (get config \"salt\" 0)\n     extrapolate? (get config \"extrapolate\" false)\n     ]\n    {:sample (cond\n               (>= threshold factor)\n               default-sampler\n               (= strategy \"RANDOM\")\n               (partial random-sampler factor threshold)\n               (= strategy \"STICKY\")\n               (partial sticky-sampler ks salt factor threshold)\n               :else default-sampler)\n     :extrapolation (if extrapolate?\n                      (sample-config->extrapolation-fn config)\n                      identity)\n     }))\n","~:reader-features",["^8",["~:cljs"]],"~:source-map",["^ ","~i5",["^ ","~i0",[["^ ","~:gcol",0,"~:gline",3],["^ ","^W",46,"^X",3],["^ ","^W",0,"^X",4]],"~i7",[["^ ","^W",0,"^X",3,"^9","io.mantisrx.mql.compilers.core.sampling/abs"]]],"~i6",["^ ","~i9",[["^ ","^W",100,"^X",3,"^9","x"]]],"~i7",["^ ","~i2",[["^ ","^W",0,"^X",4]],"~i6",[["^ ","^W",3,"^X",4],["^ ","^W",8,"^X",4]],"~i12",[["^ ","^W",4,"^X",4,"^9","x"]],"~i15",[["^ ","^W",0,"^X",5]],"~i18",[["^ ","^W",10,"^X",5,"^9","x"]],"~i21",[["^ ","^W",0,"^X",7,"^9","x"]]],"~i9",["^ ","~i0",[["^ ","^W",0,"^X",10],["^ ","^W",49,"^X",10],["^ ","^W",0,"^X",11]],"~i7",[["^ ","^W",0,"^X",10,"^9","io.mantisrx.mql.compilers.core.sampling/hasher"]]],"~i10",["^ ","~i17",[["^ ","^W",106,"^X",10,"^9","x"]],"~i25",[["^ ","^W",108,"^X",10,"^9","salt"]]],"~i11",["^ ","~i2",[["^ ","^W",0,"^X",11]],"~i3",[["^ ","^W",7,"^X",11,"^9","io.mantisrx.mql.compilers.core.sampling/abs"]],"~i7",[["^ ","^W",51,"^X",11]],"~i8",[["^ ","^W",51,"^X",11,"^9","cljs.core/hash"]],"~i13",[["^ ","^W",66,"^X",11]],"^[",[["^ ","^W",111,"^X",11,"^9","x"]],"~i20",[["^ ","^W",158,"^X",11,"^9","salt"]]],"^15",["^ ","~i0",[["^ ","^W",0,"^X",13],["^ ","^W",58,"^X",16],["^ ","^W",0,"^X",17],["^ ","^W",0,"^X",17]],"~i6",[["^ ","^W",0,"^X",16,"^9","io.mantisrx.mql.compilers.core.sampling/default-sampler"]]],"^Z",["^ ","~i3",[["^ ","^W",124,"^X",16,"^9","datum"]]],"^[",["^ ","~i0",[["^ ","^W",0,"^X",19],["^ ","^W",57,"^X",42],["^ ","^W",0,"^X",43]],"~i6",[["^ ","^W",0,"^X",42,"^9","io.mantisrx.mql.compilers.core.sampling/random-sampler"]]],"~i40",["^ ","~i3",[["^ ","^W",122,"^X",42,"^9","factor"]],"^11",[["^ ","^W",129,"^X",42,"^9","threshold"]],"^16",[["^ ","^W",139,"^X",42,"^9","datum"]]],"~i41",["^ ","~i2",[["^ ","^W",0,"^X",43]],"~i5",[["^ ","^W",8,"^X",43]],"~i6",[["^ ","^W",8,"^X",43,"^9","cljs.core/mod"]],"^11",[["^ ","^W",22,"^X",43],["^ ","^W",41,"^X",43]],"^14",[["^ ","^W",22,"^X",43,"^9","cljs.core/rand-int"]],"~i32",[["^ ","^W",55,"^X",43,"^9","factor"]],"^17",[["^ ","^W",65,"^X",43,"^9","threshold"]]],"~i43",["^ ","~i0",[["^ ","^W",0,"^X",45],["^ ","^W",57,"^X",68],["^ ","^W",0,"^X",69]],"~i6",[["^ ","^W",0,"^X",68,"^9","io.mantisrx.mql.compilers.core.sampling/sticky-sampler"]]],"~i65",["^ ","~i3",[["^ ","^W",122,"^X",68,"^9","ks"]],"~i6",[["^ ","^W",125,"^X",68,"^9","salt"]],"^14",[["^ ","^W",130,"^X",68,"^9","factor"]],"^[",[["^ ","^W",137,"^X",68,"^9","threshold"]],"~i28",[["^ ","^W",147,"^X",68,"^9","datum"]]],"~i66",["^ ","~i2",[["^ ","^W",0,"^X",69],["^ ","^W",0,"^X",72]]],"~i67",["^ ","~i5",[["^ ","^W",4,"^X",69,"^9","str-to-hash"]],"^12",[["^ ","^W",18,"^X",69]],"^[",[["^ ","^W",18,"^X",69,"^9","cljs.core.apply.cljs$core$IFn$_invoke$arity$2"]],"~i24",[["^ ","^W",64,"^X",69,"^9","cljs.core/str"]],"^1<",[["^ ","^W",78,"^X",69],["^ ","^W",122,"^X",69],["^ ","^W",133,"^X",69,"^9","p1__31573#"],["^ ","^W",0,"^X",70]],"~i29",[["^ ","^W",78,"^X",69,"^9","cljs.core.map.cljs$core$IFn$_invoke$arity$2"]],"~i34",[["^ ","^W",0,"^X",70],["^ ","^W",57,"^X",70,"^9","p1__31573#"]],"~i35",[["^ ","^W",7,"^X",70,"^9","cljs.core.get.cljs$core$IFn$_invoke$arity$2"]],"~i39",[["^ ","^W",51,"^X",70,"^9","datum"]],"~i48",[["^ ","^W",3,"^X",71,"^9","ks"]]],"~i68",["^ ","~i4",[["^ ","^W",0,"^X",72],["^ ","^W",0,"^X",73],["^ ","^W",0,"^X",75],["^ ","^W",0,"^X",76],["^ ","^W",0,"^X",78],["^ ","^W",0,"^X",78]]],"~i69",["^ ","~i6",[["^ ","^W",3,"^X",72],["^ ","^W",60,"^X",72]],"~i7",[["^ ","^W",3,"^X",72,"^9","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2"]],"^12",[["^ ","^W",48,"^X",72,"^9","str-to-hash"]]],"~i70",["^ ","~i6",[["^ ","^W",3,"^X",75]],"~i9",[["^ ","^W",4,"^X",75]],"^11",[["^ ","^W",4,"^X",75,"^9","cljs.core/mod"]],"~i14",[["^ ","^W",18,"^X",75]],"^Z",[["^ ","^W",18,"^X",75,"^9","io.mantisrx.mql.compilers.core.sampling/hasher"]],"~i22",[["^ ","^W",65,"^X",75,"^9","str-to-hash"]],"^1A",[["^ ","^W",77,"^X",75,"^9","salt"]],"^17",[["^ ","^W",83,"^X",75,"^9","factor"]],"^1D",[["^ ","^W",93,"^X",75,"^9","threshold"]]],"~i73",["^ ","~i0",[["^ ","^W",0,"^X",83],["^ ","^W",53,"^X",91],["^ ","^W",0,"^X",92]],"~i7",[["^ ","^W",0,"^X",91,"^9","io.mantisrx.mql.compilers.core.sampling/parse-json"]]],"~i80",["^ ","~i3",[["^ ","^W",114,"^X",91,"^9","string"]]],"~i82",["^ ","^14",[["^ ","^W",0,"^X",92]],"^Y",[["^ ","^W",7,"^X",92,"^9","cljs.core.js__GT_clj.cljs$core$IFn$_invoke$arity$1"]],"^16",[["^ ","^W",58,"^X",92]],"^1<",[["^ ","^W",58,"^X",92,"^9","js/JSON"]],"~i36",[["^ ","^W",69,"^X",92,"^9","string"]]],"~i84",["^ ","~i0",[["^ ","^W",0,"^X",94],["^ ","^W",57,"^X",94]],"~i5",[["^ ","^W",0,"^X",94,"^9","io.mantisrx.mql.compilers.core.sampling/default-factor"]]],"~i86",["^ ","~i0",[["^ ","^W",0,"^X",95],["^ ","^W",81,"^X",95],["^ ","^W",0,"^X",96]],"~i6",[["^ ","^W",0,"^X",95,"^9","io.mantisrx.mql.compilers.core.sampling/sample-config->extrapolation-factor"]]],"~i87",["^ ","~i3",[["^ ","^W",170,"^X",95,"^9","config"]]],"~i88",["^ ","~i2",[["^ ","^W",0,"^X",96],["^ ","^W",0,"^X",98]]],"~i89",["^ ","~i5",[["^ ","^W",4,"^X",96,"^9","threshold"]],"^Z",[["^ ","^W",16,"^X",96],["^ ","^W",67,"^X",96]],"~i16",[["^ ","^W",16,"^X",96,"^9","cljs.core.get.cljs$core$IFn$_invoke$arity$3"]],"^16",[["^ ","^W",60,"^X",96,"^9","config"]],"^1C",[["^ ","^W",79,"^X",96,"^9","io.mantisrx.mql.compilers.core.sampling/default-factor"]]],"~i90",["^ ","~i5",[["^ ","^W",4,"^X",97,"^9","factor"]],"^Y",[["^ ","^W",13,"^X",97],["^ ","^W",64,"^X",97]],"^15",[["^ ","^W",13,"^X",97,"^9","cljs.core.get.cljs$core$IFn$_invoke$arity$3"]],"^12",[["^ ","^W",57,"^X",97,"^9","config"]],"~i33",[["^ ","^W",73,"^X",97,"^9","io.mantisrx.mql.compilers.core.sampling/default-factor"]]],"~i91",["^ ","^Y",[["^ ","^W",0,"^X",98]],"^Z",[["^ ","^W",8,"^X",98,"^9","factor"]],"^1I",[["^ ","^W",17,"^X",98,"^9","threshold"]]],"~i93",["^ ","~i0",[["^ ","^W",0,"^X",100],["^ ","^W",64,"^X",100],["^ ","^W",0,"^X",101]],"~i7",[["^ ","^W",0,"^X",100,"^9","io.mantisrx.mql.compilers.core.sampling/extrapolatable?"]]],"~i94",["^ ","~i3",[["^ ","^W",136,"^X",100,"^9","x"]]],"~i95",["^ ","~i2",[["^ ","^W",0,"^X",101]],"~i6",[["^ ","^W",8,"^X",101],["^ ","^W",44,"^X",101]],"~i7",[["^ ","^W",8,"^X",101,"^9","clojure.string/starts-with?"]],"~i27",[["^ ","^W",42,"^X",101,"^9","x"]]],"~i96",["^ ","~i6",[["^ ","^W",57,"^X",101],["^ ","^W",93,"^X",101]],"~i7",[["^ ","^W",57,"^X",101,"^9","clojure.string/starts-with?"]],"^1Z",[["^ ","^W",91,"^X",101,"^9","x"]]],"~i98",["^ ","~i0",[["^ ","^W",0,"^X",103],["^ ","^W",77,"^X",103],["^ ","^W",0,"^X",104]],"~i6",[["^ ","^W",0,"^X",103,"^9","io.mantisrx.mql.compilers.core.sampling/sample-config->extrapolation-fn"]]],"~i99",["^ ","~i3",[["^ ","^W",162,"^X",103,"^9","raw-config"]]],"~i100",["^ ","~i2",[["^ ","^W",0,"^X",104],["^ ","^W",0,"^X",106]],"~i8",[["^ ","^W",4,"^X",104,"^9","config"]],"^Z",[["^ ","^W",13,"^X",104]],"^1S",[["^ ","^W",13,"^X",104,"^9","io.mantisrx.mql.compilers.core.sampling/parse-json"]],"^1Z",[["^ ","^W",64,"^X",104],["^ ","^W",98,"^X",104],["^ ","^W",102,"^X",104]],"^1<",[["^ ","^W",64,"^X",104,"^9","clojure.string/replace"]],"~i51",[["^ ","^W",87,"^X",104,"^9","raw-config"]]],"~i101",["^ ","~i8",[["^ ","^W",4,"^X",105,"^9","factor"]],"^Z",[["^ ","^W",13,"^X",105]],"^1S",[["^ ","^W",13,"^X",105,"^9","io.mantisrx.mql.compilers.core.sampling/sample-config->extrapolation-factor"]],"~i52",[["^ ","^W",92,"^X",105,"^9","config"]]],"~i102",["^ ","~i4",[["^ ","^W",0,"^X",106]],"~i8",[["^ ","^W",20,"^X",106],["^ ","^W",71,"^X",106],["^ ","^W",85,"^X",106]],"~i9",[["^ ","^W",20,"^X",106,"^9","cljs.core.get.cljs$core$IFn$_invoke$arity$3"]],"^15",[["^ ","^W",64,"^X",106,"^9","config"]]],"~i103",["^ ","~i6",[["^ ","^W",0,"^X",107],["^ ","^W",0,"^X",109]],"^14",[["^ ","^W",18,"^X",108,"^9","datum"]]],"~i104",["^ ","~i8",[["^ ","^W",0,"^X",109],["^ ","^W",0,"^X",110]]],"~i105",["^ ","^14",[["^ ","^W",4,"^X",109,"^9","names"]],"^12",[["^ ","^W",12,"^X",109]],"^[",[["^ ","^W",12,"^X",109,"^9","cljs.core.filter.cljs$core$IFn$_invoke$arity$2"]],"^13",[["^ ","^W",59,"^X",109,"^9","io.mantisrx.mql.compilers.core.sampling/extrapolatable?"]],"^18",[["^ ","^W",121,"^X",109]],"~i42",[["^ ","^W",121,"^X",109,"^9","cljs.core/keys"]],"~i47",[["^ ","^W",136,"^X",109,"^9","datum"]]],"~i106",["^ ","^11",[["^ ","^W",0,"^X",110],["^ ","^W",12,"^X",110,"^9","java/util.TreeMap"]]],"~i107",["^ ","^Y",[["^ ","^W",30,"^X",110]],"^1<",[["^ ","^W",30,"^X",110,"^9","cljs.core.apply.cljs$core$IFn$_invoke$arity$2"]],"^1A",[["^ ","^W",76,"^X",110]],"^1B",[["^ ","^W",76,"^X",110,"^9","cljs.core.partial.cljs$core$IFn$_invoke$arity$2"]],"^1:",[["^ ","^W",124,"^X",110,"^9","cljs.core/merge"]],"~i49",[["^ ","^W",140,"^X",110],["^ ","^W",185,"^X",110]],"~i50",[["^ ","^W",140,"^X",110,"^9","cljs.core.into.cljs$core$IFn$_invoke$arity$2"]],"~i58",[["^ ","^W",220,"^X",110,"^9","datum"]]],"~i108",["^ ","^1A",[["^ ","^W",228,"^X",110]],"^1B",[["^ ","^W",228,"^X",110,"^9","cljs.core.map.cljs$core$IFn$_invoke$arity$2"]],"^1C",[["^ ","^W",272,"^X",110],["^ ","^W",0,"^X",112],["^ ","^W",0,"^X",112]],"~i44",[["^ ","^W",18,"^X",111,"^9","name"]],"^23",[["^ ","^W",55,"^X",112,"^9","name"]],"~i56",[["^ ","^W",60,"^X",112]],"~i59",[["^ ","^W",61,"^X",112,"^9","factor"]],"^1=",[["^ ","^W",70,"^X",112]],"^1>",[["^ ","^W",70,"^X",112,"^9","cljs.core.get.cljs$core$IFn$_invoke$arity$2"]],"~i71",[["^ ","^W",114,"^X",112,"^9","datum"]],"~i77",[["^ ","^W",120,"^X",112,"^9","name"]],"^1O",[["^ ","^W",1,"^X",114,"^9","names"]]],"~i109",["^ ","~i6",[["^ ","^W",0,"^X",118,"^9","cljs.core/identity"]]],"~i112",["^ ","~i0",[["^ ","^W",0,"^X",121],["^ ","^W",68,"^X",132],["^ ","^W",0,"^X",133]],"~i6",[["^ ","^W",0,"^X",132,"^9","io.mantisrx.mql.compilers.core.sampling/sample-config->sampler"]]],"~i122",["^ ","~i3",[["^ ","^W",144,"^X",132,"^9","raw-config"]]],"~i123",["^ ","~i2",[["^ ","^W",0,"^X",133],["^ ","^W",0,"^X",140],["^ ","^W",0,"^X",140],["^ ","^W",50,"^X",140],["^ ","^W",4,"^X",141]]],"~i124",["^ ","~i5",[["^ ","^W",4,"^X",133,"^9","config"]],"^Y",[["^ ","^W",13,"^X",133]],"^15",[["^ ","^W",13,"^X",133,"^9","io.mantisrx.mql.compilers.core.sampling/parse-json"]],"^1?",[["^ ","^W",64,"^X",133],["^ ","^W",98,"^X",133],["^ ","^W",102,"^X",133]],"^13",[["^ ","^W",64,"^X",133,"^9","clojure.string/replace"]],"^1D",[["^ ","^W",87,"^X",133,"^9","raw-config"]]],"~i125",["^ ","~i5",[["^ ","^W",4,"^X",134,"^9","strategy"]],"^1H",[["^ ","^W",15,"^X",134],["^ ","^W",66,"^X",134],["^ ","^W",77,"^X",134]],"^Z",[["^ ","^W",15,"^X",134,"^9","cljs.core.get.cljs$core$IFn$_invoke$arity$3"]],"~i19",[["^ ","^W",59,"^X",134,"^9","config"]]],"~i126",["^ ","~i5",[["^ ","^W",4,"^X",135,"^9","threshold"]],"^Z",[["^ ","^W",16,"^X",135],["^ ","^W",67,"^X",135]],"^1S",[["^ ","^W",16,"^X",135,"^9","cljs.core.get.cljs$core$IFn$_invoke$arity$3"]],"^16",[["^ ","^W",60,"^X",135,"^9","config"]],"^1C",[["^ ","^W",79,"^X",135,"^9","io.mantisrx.mql.compilers.core.sampling/default-factor"]]],"~i127",["^ ","~i5",[["^ ","^W",4,"^X",136,"^9","factor"]],"^Y",[["^ ","^W",13,"^X",136],["^ ","^W",64,"^X",136]],"^15",[["^ ","^W",13,"^X",136,"^9","cljs.core.get.cljs$core$IFn$_invoke$arity$3"]],"^12",[["^ ","^W",57,"^X",136,"^9","config"]],"^1U",[["^ ","^W",73,"^X",136,"^9","io.mantisrx.mql.compilers.core.sampling/default-factor"]]],"~i128",["^ ","~i5",[["^ ","^W",4,"^X",137,"^9","ks"]],"~i8",[["^ ","^W",9,"^X",137],["^ ","^W",60,"^X",137],["^ ","^W",67,"^X",137]],"~i9",[["^ ","^W",9,"^X",137,"^9","cljs.core.get.cljs$core$IFn$_invoke$arity$3"]],"^15",[["^ ","^W",53,"^X",137,"^9","config"]]],"~i129",["^ ","~i5",[["^ ","^W",4,"^X",138,"^9","salt"]],"^11",[["^ ","^W",11,"^X",138],["^ ","^W",62,"^X",138],["^ ","^W",69,"^X",138]],"^14",[["^ ","^W",11,"^X",138,"^9","cljs.core.get.cljs$core$IFn$_invoke$arity$3"]],"^Z",[["^ ","^W",55,"^X",138,"^9","config"]]],"~i130",["^ ","~i5",[["^ ","^W",4,"^X",139,"^9","extrapolate?"]],"^[",[["^ ","^W",25,"^X",139],["^ ","^W",76,"^X",139],["^ ","^W",90,"^X",139]],"^2M",[["^ ","^W",25,"^X",139,"^9","cljs.core.get.cljs$core$IFn$_invoke$arity$3"]],"~i23",[["^ ","^W",69,"^X",139,"^9","config"]]],"~i132",["^ ","^15",[["^ ","^W",105,"^X",140],["^ ","^W",186,"^X",140],["^ ","^W",374,"^X",140],["^ ","^W",632,"^X",140]]],"~i133",["^ ","^Z",[["^ ","^W",107,"^X",140]],"^2M",[["^ ","^W",108,"^X",140,"^9","threshold"]],"^1@",[["^ ","^W",121,"^X",140,"^9","factor"]]],"~i134",["^ ","^Z",[["^ ","^W",130,"^X",140,"^9","io.mantisrx.mql.compilers.core.sampling/default-sampler"]]],"~i135",["^ ","^Z",[["^ ","^W",188,"^X",140],["^ ","^W",242,"^X",140]],"^1S",[["^ ","^W",188,"^X",140,"^9","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2"]],"^[",[["^ ","^W",233,"^X",140,"^9","strategy"]]],"~i136",["^ ","^Z",[["^ ","^W",253,"^X",140]],"^1S",[["^ ","^W",253,"^X",140,"^9","cljs.core.partial.cljs$core$IFn$_invoke$arity$3"]],"^1?",[["^ ","^W",301,"^X",140,"^9","io.mantisrx.mql.compilers.core.sampling/random-sampler"]],"^1C",[["^ ","^W",356,"^X",140,"^9","factor"]],"~i46",[["^ ","^W",363,"^X",140,"^9","threshold"]]],"~i137",["^ ","^Z",[["^ ","^W",376,"^X",140],["^ ","^W",430,"^X",140]],"^1S",[["^ ","^W",376,"^X",140,"^9","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2"]],"^[",[["^ ","^W",421,"^X",140,"^9","strategy"]]],"~i138",["^ ","^Z",[["^ ","^W",441,"^X",140]],"^1S",[["^ ","^W",441,"^X",140,"^9","cljs.core.partial.cljs$core$IFn$_invoke$arity$variadic"]],"^1?",[["^ ","^W",496,"^X",140,"^9","io.mantisrx.mql.compilers.core.sampling/sticky-sampler"]],"^1C",[["^ ","^W",551,"^X",140,"^9","ks"]],"^2:",[["^ ","^W",554,"^X",140,"^9","salt"]],"^2;",[["^ ","^W",559,"^X",140,"^9","factor"]],"~i54",[["^ ","^W",616,"^X",140,"^9","threshold"]]],"~i139",["^ ","^10",[["^ ","^W",632,"^X",140,"^9","io.mantisrx.mql.compilers.core.sampling/default-sampler"]]],"~i140",["^ ","^16",[["^ ","^W",75,"^X",141]],"^1?",[["^ ","^W",93,"^X",141,"^9","extrapolate?"]]],"~i141",["^ ","^1I",[["^ ","^W",113,"^X",141]],"^2S",[["^ ","^W",113,"^X",141,"^9","io.mantisrx.mql.compilers.core.sampling/sample-config->extrapolation-fn"]],"~i55",[["^ ","^W",188,"^X",141,"^9","config"]]],"~i142",["^ ","^1I",[["^ ","^W",196,"^X",141,"^9","cljs.core/identity"]]]],"~:cljc",true],"~:cache-keys",["~#cmap",[["~:macro","^A"],1516731430000,["^O","goog/math/math.js"],1516731431000,["^O","goog/array/array.js"],1516731431000,["^O","goog/debug/error.js"],1516731431000,["^O","goog/dom/nodetype.js"],1516731431000,["^O","goog/object/object.js"],1516731431000,"~:SHADOW-TIMESTAMP",1516731432000,["^O","goog/math/long.js"],1516731431000,["^O","goog/functions/functions.js"],1516731431000,["^O","goog/structs/map.js"],1516731431000,["^O","io/mantisrx/mql/compilers/core/sampling.cljc"],[1526321141000],["^O","goog/asserts/asserts.js"],1516731431000,["^O","goog/uri/uri.js"],1516731431000,["^O","goog/base.js"],1516731431000,["^O","goog/structs/structs.js"],1516731431000,["^O","clojure/string.cljs"],1516731430000,["^O","goog/string/string.js"],1516731431000,["^O","goog/reflect/reflect.js"],1516731431000,["^O","goog/string/stringbuffer.js"],1516731431000,["^O","goog/iter/iter.js"],1516731431000,["^O","cljs/core.cljs"],1516731430000,["^O","goog/math/integer.js"],1516731431000,["^O","goog/uri/utils.js"],1516731431000]],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ "],"^6",null,"^7",["^8",[]],"~:shadow/js-access-properties",["^8",["parse"]],"^9","^:","^=",null,"^>",["^ ","^?","^?","^@","^?","^A","^A","^B","^B"],"^C",["^8",["^D"]],"~:shadow/js-access-global",["^8",["JSON"]],"^E",null,"~:defs",["^ ","~$sample-config->extrapolation-factor",["^ ","~:protocol-inline",null,"^5",["^ ","~:file","io/mantisrx/mql/compilers/core/sampling.cljc","~:line",87,"~:column",7,"~:end-line",87,"~:end-column",42,"~:arglists",["^H",["~$quote",["^H",[["~$config"]]]]]],"^9","~$io.mantisrx.mql.compilers.core.sampling/sample-config->extrapolation-factor","~:variadic",false,"^3A","io/mantisrx/mql/compilers/core/sampling.cljc","^3E",42,"~:method-params",["^H",[["^3H"]]],"~:protocol-impl",null,"~:arglists-meta",["^H",[null,null]],"^3C",1,"^3B",87,"^3D",87,"~:max-fixed-arity",1,"~:fn-var",true,"^3F",["^H",["^3G",["^H",[["^3H"]]]]]],"~$extrapolatable?",["^ ","^3@",null,"^5",["^ ","^3A","io/mantisrx/mql/compilers/core/sampling.cljc","^3B",94,"^3C",8,"^3D",94,"^3E",23,"~:private",true,"^3F",["^H",["^3G",["^H",[["~$x"]]]]]],"^3Q",true,"^9","~$io.mantisrx.mql.compilers.core.sampling/extrapolatable?","^3J",false,"^3A","io/mantisrx/mql/compilers/core/sampling.cljc","^3E",23,"^3K",["^H",[["~$x"]]],"^3L",null,"^3M",["^H",[null,null]],"^3C",1,"^3B",94,"^3D",94,"^3N",1,"^3O",true,"^3F",["^H",["^3G",["^H",[["~$x"]]]]]],"~$default-factor",["^ ","^9","~$io.mantisrx.mql.compilers.core.sampling/default-factor","^3A","io/mantisrx/mql/compilers/core/sampling.cljc","^3B",85,"^3C",1,"^3D",85,"^3E",20,"^5",["^ ","^3A","io/mantisrx/mql/compilers/core/sampling.cljc","^3B",85,"^3C",6,"^3D",85,"^3E",20],"~:tag","~$number"],"~$sticky-sampler",["^ ","^3@",null,"^5",["^ ","^3A","io/mantisrx/mql/compilers/core/sampling.cljc","^3B",44,"^3C",7,"^3D",44,"^3E",21,"^3F",["^H",["^3G",["^H",[["~$ks","~$salt","~$factor","~$threshold","~$datum"]]]]],"~:doc","A sticky sampler will 'stick' to certain values for the specified keys.\n   As an example if use esn as a key then esn=NFANDROID-FOO is sampled then\n   the stream will always sample data for which esn=NFANDROID-FOO. This is\n   determined using the hash of all the values concatenated as a string. Unlike\n   the random sampler the sticky sampler is is deterministic and referentially\n   transparent.\n\n   This is useful in use cases such as sessionization in which we want to\n   process only a sample of the stream, but unlike random sampling we want\n   to ensure we see all data sampled matches the criteria.\n\n   As with the random sampler the factor and threshold parameters can be used\n   to control the volume of data. See (doc random-sampler) for more details.\n\n   ks: A seq of keys at the top level of datum used for stickiness.\n   salt: A salt value to be added to the hash of the key values.\n   factor: A uniform random number will be generated on the interval [0 factor)\n   threshold: datum is sampled if said uniform random number is below threshold.\n   datum: A map of String -> Object representing the data to be sampled.\n\n   Returns true if the datum should be sampled, false otherwise."],"^9","~$io.mantisrx.mql.compilers.core.sampling/sticky-sampler","^3J",false,"^3A","io/mantisrx/mql/compilers/core/sampling.cljc","^3E",21,"^3K",["^H",[["^3X","^3Y","^3Z","^3[","^40"]]],"^3L",null,"^3M",["^H",[null,null]],"^3C",1,"^3B",44,"^3D",44,"^3N",5,"^3O",true,"^3F",["^H",["^3G",["^H",[["^3X","^3Y","^3Z","^3[","^40"]]]]],"^41","A sticky sampler will 'stick' to certain values for the specified keys.\n   As an example if use esn as a key then esn=NFANDROID-FOO is sampled then\n   the stream will always sample data for which esn=NFANDROID-FOO. This is\n   determined using the hash of all the values concatenated as a string. Unlike\n   the random sampler the sticky sampler is is deterministic and referentially\n   transparent.\n\n   This is useful in use cases such as sessionization in which we want to\n   process only a sample of the stream, but unlike random sampling we want\n   to ensure we see all data sampled matches the criteria.\n\n   As with the random sampler the factor and threshold parameters can be used\n   to control the volume of data. See (doc random-sampler) for more details.\n\n   ks: A seq of keys at the top level of datum used for stickiness.\n   salt: A salt value to be added to the hash of the key values.\n   factor: A uniform random number will be generated on the interval [0 factor)\n   threshold: datum is sampled if said uniform random number is below threshold.\n   datum: A map of String -> Object representing the data to be sampled.\n\n   Returns true if the datum should be sampled, false otherwise."],"~$sample-config->extrapolation-fn",["^ ","^3@",null,"^5",["^ ","^3A","io/mantisrx/mql/compilers/core/sampling.cljc","^3B",99,"^3C",7,"^3D",99,"^3E",38,"^3F",["^H",["^3G",["^H",[["~$raw-config"]]]]]],"^9","~$io.mantisrx.mql.compilers.core.sampling/sample-config->extrapolation-fn","^3J",false,"^3A","io/mantisrx/mql/compilers/core/sampling.cljc","^3E",38,"^3K",["^H",[["^44"]]],"^3L",null,"^3M",["^H",[null,null]],"^3C",1,"^3B",99,"^3D",99,"^3N",1,"^3O",true,"^3F",["^H",["^3G",["^H",[["^44"]]]]]],"~$sample-config->sampler",["^ ","^3@",null,"^5",["^ ","^3A","io/mantisrx/mql/compilers/core/sampling.cljc","^3B",113,"^3C",7,"^3D",113,"^3E",29,"^3F",["^H",["^3G",["^H",[["^44"]]]]],"^41","Converts a json sampler configuration into a function which can then\n   be used to determine sampling eligibility by applying to data. Intended\n   for use with the filter function and behaves like a predicate.\n\n   raw-config: A JSON string representing the configuration for the sampler.\n   This function will replace single quotes with double quotes first.\n\n   Returns a function of datum -> boolean indicating eligibility for sampling\n   in which datum is a map of String -> Object."],"^9","~$io.mantisrx.mql.compilers.core.sampling/sample-config->sampler","^3J",false,"^3A","io/mantisrx/mql/compilers/core/sampling.cljc","^3E",29,"^3K",["^H",[["^44"]]],"^3L",null,"^3M",["^H",[null,null]],"^3C",1,"^3B",113,"^3D",113,"^3N",1,"^3O",true,"^3F",["^H",["^3G",["^H",[["^44"]]]]],"^41","Converts a json sampler configuration into a function which can then\n   be used to determine sampling eligibility by applying to data. Intended\n   for use with the filter function and behaves like a predicate.\n\n   raw-config: A JSON string representing the configuration for the sampler.\n   This function will replace single quotes with double quotes first.\n\n   Returns a function of datum -> boolean indicating eligibility for sampling\n   in which datum is a map of String -> Object."],"~$random-sampler",["^ ","^3@",null,"^5",["^ ","^3A","io/mantisrx/mql/compilers/core/sampling.cljc","^3B",19,"^3C",7,"^3D",19,"^3E",21,"^3F",["^H",["^3G",["^H",[["^3Z","^3[","^40"]]]]],"^41","Implementation for the random sampler, this specific implementation using\n   the hard coded 2^32 is to maintain ClojureScript compatibility. The design\n   has been ported from mantis-query (the old query language) to maintain\n   identical behavior. The random sampler is not deterministic, and consequently\n   not referentially transparent.\n\n   factor: A uniform random number will be generated on the interval [0 factor).\n   threshold: datum is sampled if said uniform random number is below threshold.\n   datum: A map of String -> Object representing the data to be sampled.\n\n   Sampling criteria:\n   x ~ uniform [0 factor)\n   x <= threshold\n\n   1% random sampling:  (random-sampler 100 10000)\n   2% random sampling:  (random-sampler 200 10000)\n   2% random sampling:  (random-sampler 100 5000)\n   10% random sampling: (random-sampler 10 100)\n   25% random sampling: (random-sampler 2500 10000)\n\n   Returns true if the datum should be sampled, false otherwise."],"^9","~$io.mantisrx.mql.compilers.core.sampling/random-sampler","^3J",false,"^3A","io/mantisrx/mql/compilers/core/sampling.cljc","^3E",21,"^3K",["^H",[["^3Z","^3[","^40"]]],"^3L",null,"^3M",["^H",[null,null]],"^3C",1,"^3B",19,"^3D",19,"^3N",3,"^3O",true,"^3F",["^H",["^3G",["^H",[["^3Z","^3[","^40"]]]]],"^41","Implementation for the random sampler, this specific implementation using\n   the hard coded 2^32 is to maintain ClojureScript compatibility. The design\n   has been ported from mantis-query (the old query language) to maintain\n   identical behavior. The random sampler is not deterministic, and consequently\n   not referentially transparent.\n\n   factor: A uniform random number will be generated on the interval [0 factor).\n   threshold: datum is sampled if said uniform random number is below threshold.\n   datum: A map of String -> Object representing the data to be sampled.\n\n   Sampling criteria:\n   x ~ uniform [0 factor)\n   x <= threshold\n\n   1% random sampling:  (random-sampler 100 10000)\n   2% random sampling:  (random-sampler 200 10000)\n   2% random sampling:  (random-sampler 100 5000)\n   10% random sampling: (random-sampler 10 100)\n   25% random sampling: (random-sampler 2500 10000)\n\n   Returns true if the datum should be sampled, false otherwise."],"~$hasher",["^ ","^3@",null,"^5",["^ ","^3A","io/mantisrx/mql/compilers/core/sampling.cljc","^3B",10,"^3C",8,"^3D",10,"^3E",14,"^3Q",true,"^3F",["^H",["^3G",["^H",[["~$x","^3Y"]]]]]],"^3Q",true,"^9","~$io.mantisrx.mql.compilers.core.sampling/hasher","^3J",false,"^3A","io/mantisrx/mql/compilers/core/sampling.cljc","^3E",14,"^3K",["^H",[["~$x","^3Y"]]],"^3L",null,"^3M",["^H",[null,null]],"^3C",1,"^3B",10,"^3D",10,"^3N",2,"^3O",true,"^3F",["^H",["^3G",["^H",[["~$x","^3Y"]]]]]],"~$abs",["^ ","^3@",null,"^5",["^ ","^3A","io/mantisrx/mql/compilers/core/sampling.cljc","^3B",6,"^3C",8,"^3D",6,"^3E",11,"^3Q",true,"^3F",["^H",["^3G",["^H",[["~$x"]]]]]],"^3Q",true,"^9","~$io.mantisrx.mql.compilers.core.sampling/abs","^3J",false,"^3A","io/mantisrx/mql/compilers/core/sampling.cljc","^3E",11,"^3K",["^H",[["~$x"]]],"^3L",null,"^3M",["^H",[null,null]],"^3C",1,"^3B",6,"^3D",6,"^3N",1,"^3O",true,"^3F",["^H",["^3G",["^H",[["~$x"]]]]]],"~$parse-json",["^ ","^3@",null,"^5",["^ ","^3A","io/mantisrx/mql/compilers/core/sampling.cljc","^3B",74,"^3C",8,"^3D",74,"^3E",18,"^3Q",true,"^3F",["^H",["^3G",["^H",[["^@"]]]]],"^41","A cross platform json parsing function which defers to host specific\n   parsers.\n\n   string: A string representing valid JSON.\n\n   Returns nested maps and vectors representing the parsed data."],"^3Q",true,"^9","~$io.mantisrx.mql.compilers.core.sampling/parse-json","^3J",false,"^3A","io/mantisrx/mql/compilers/core/sampling.cljc","^3E",18,"^3K",["^H",[["^@"]]],"^3L",null,"^3M",["^H",[null,null]],"^3C",1,"^3B",74,"^3D",74,"^3N",1,"^3O",true,"^3F",["^H",["^3G",["^H",[["^@"]]]]],"^41","A cross platform json parsing function which defers to host specific\n   parsers.\n\n   string: A string representing valid JSON.\n\n   Returns nested maps and vectors representing the parsed data."],"~$default-sampler",["^ ","^3@",null,"^5",["^ ","^3A","io/mantisrx/mql/compilers/core/sampling.cljc","^3B",14,"^3C",7,"^3D",14,"^3E",22,"^3F",["^H",["^3G",["^H",[["^40"]]]]],"^41","A tautology function of datum -> true."],"^9","~$io.mantisrx.mql.compilers.core.sampling/default-sampler","^3J",false,"^3A","io/mantisrx/mql/compilers/core/sampling.cljc","^3E",22,"^3K",["^H",[["^40"]]],"^3L",null,"^3M",["^H",[null,null]],"^3C",1,"^3B",14,"^3D",14,"^3N",1,"^3O",true,"^3F",["^H",["^3G",["^H",[["^40"]]]]],"^41","A tautology function of datum -> true."]],"^F",["^ ","^A","^A"],"~:cljs.analyzer/constants",["^ ","^C",["^8",["~:else","~:default","~:sample","~:extrapolation"]],"~:order",["^4C","^4D","^4E","^4F"]],"^K",["^ ","^D",["^8",[]]],"^L",["^ "],"^M",["^B","^A","^?"]],"^<","^:","~:ns-specs",["^ "],"~:ns-speced-vars",[],"~:compiler-options",["^38",[["^4J","~:static-fns"],true,["^4J","~:elide-asserts"],false,["^4J","~:optimize-constants"],null,["^4J","~:emit-constants"],null,["^4J","~:infer-externs"],true,["^4J","^T"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^4J","~:fn-invoke-direct"],null,["^4J","^V"],"/dev/null"]]]