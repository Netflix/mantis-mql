configurations {
    shadedAndRelocatedConfiguration
    implementation.extendsFrom shadedAndRelocatedConfiguration
}

repositories { 
  mavenCentral()
  maven { url "https://clojars.org/repo" }
}

compileTestJava {
    options.compilerArgs << "-Xlint:unchecked" << "-Xlint:deprecation"
}

dependencies {
  shadedAndRelocatedConfiguration 'org.clojure:clojure:1.9.0'
  shadedAndRelocatedConfiguration 'org.clojure:data.json:0.2.3'
  shadedAndRelocatedConfiguration 'instaparse:instaparse:1.4.9'
  shadedAndRelocatedConfiguration 'io.reactivex:rxjava:1.3.8'
  // rxclojure must also be shaded because it uses clojure.* classes
  shadedAndRelocatedConfiguration 'io.reactivex:rxclojure:1.0.0'
  testImplementation 'criterium:criterium:0.4.4'
  testImplementation 'org.clojure:test.check:0.9.0'
  testImplementation 'junit:junit:4.12'
  testImplementation 'org.assertj:assertj-core:3.12.2'
  testImplementation 'com.fasterxml.jackson.module:jackson-module-afterburner:2.9.9'
  testImplementation 'com.fasterxml.jackson.dataformat:jackson-dataformat-cbor:2.9.9'
  testImplementation 'com.fasterxml.jackson.core:jackson-core:2.9.9'
  testImplementation 'com.fasterxml.jackson.core:jackson-databind:2.9.9'
  testImplementation 'com.fasterxml.jackson.core:jackson-annotations:2.9.9'
}

// Disable for gradle 7.x compatibility with netflixoss
//gradle.startParameter.excludedTaskNames += "licenseMain"
//gradle.startParameter.excludedTaskNames += "licenseTest"

import com.github.jengelman.gradle.plugins.shadow.transformers.Transformer
import com.github.jengelman.gradle.plugins.shadow.transformers.TransformerContext
import shadow.org.apache.tools.zip.ZipOutputStream
import shadow.org.apache.tools.zip.ZipEntry
import org.gradle.api.file.FileTreeElement
import org.objectweb.asm.*


/**
 * Custom transformer that rewrites .clj/.cljc source file CONTENTS during shading.
 * 
 * This is required because shadowJar's relocate only transforms:
 *   - .class file bytecode references
 *   - Resource paths (file locations)
 * 
 * But it does NOT transform the actual text content inside .clj source files.
 * Clojure loads and compiles .clj source files at runtime, and these files 
 * contain hardcoded namespace references like (in-ns 'clojure.core) and 
 * (import ...) that must match the relocated package structure.
 */
class ClojureSourceRelocateTransformer implements Transformer {
    private Map<String, String> relocations = [:]
    private Map<String, byte[]> transformedFiles = [:]

    void relocate(String pattern, String destination) {
        relocations[pattern] = destination
    }

    @Override
    boolean canTransformResource(FileTreeElement element) {
        def path = element.relativePath.pathString
        return path.endsWith('.clj') || path.endsWith('.cljc')
    }

    @Override
    void transform(TransformerContext context) {
        def path = context.path
        def content = context.is.getText('UTF-8')

        // Apply all relocations to the source content
        // Order matters: do more specific patterns first (rx.lang.clojure before clojure)
        // This prevents double-shading (e.g., clojure within io.mantisrx.mql.shaded.rx.lang.clojure)
        def sortedRelocations = relocations.sort { a, b -> b.key.length() <=> a.key.length() }
        
        // Use a placeholder approach to prevent double-replacement
        // First pass: replace with unique placeholders
        def placeholders = [:]
        int idx = 0
        sortedRelocations.each { pattern, destination ->
            def placeholder = "##SHADE_PLACEHOLDER_${idx}##"
            placeholders[placeholder] = destination
            
            // Replace namespace references (dot notation): clojure.core -> placeholder.core
            content = content.replace(pattern + '.', placeholder + '.')
            // Replace path references (slash notation): clojure/core -> placeholder/core  
            content = content.replace(pattern + '/', placeholder + '/')
            // Replace quoted symbols: 'clojure.core -> 'placeholder.core
            content = content.replace("'" + pattern, "'" + placeholder)
            
            idx++
        }
        
        // Second pass: replace placeholders with actual shaded names
        placeholders.each { placeholder, destination ->
            content = content.replace(placeholder, destination)
        }

        transformedFiles[path] = content.getBytes('UTF-8')
    }

    @Override
    boolean hasTransformedResource() {
        return !transformedFiles.isEmpty()
    }

    @Override
    void modifyOutputStream(ZipOutputStream os, boolean preserveFileTimestamps) {
        transformedFiles.each { path, bytes ->
            def zipEntry = new ZipEntry(path)
            os.putNextEntry(zipEntry)
            os.write(bytes)
            os.closeEntry()
        }
        transformedFiles.clear()
    }
}

shadowJar {
    classifier null // this configuration is used to produce only the shadowed jar
    
    // Apply relocations to bytecode (.class files) and resource paths
    relocate 'instaparse', 'io.mantisrx.mql.shaded.instaparse'
    relocate 'clojure', 'io.mantisrx.mql.shaded.clojure'
    relocate 'rx.lang.clojure', 'io.mantisrx.mql.shaded.rx.lang.clojure'
    
    // Also transform .clj/.cljc source file CONTENTS with the same relocations
    def clojureTransformer = new ClojureSourceRelocateTransformer()
    clojureTransformer.relocate('instaparse', 'io.mantisrx.mql.shaded.instaparse')
    clojureTransformer.relocate('clojure', 'io.mantisrx.mql.shaded.clojure')
    clojureTransformer.relocate('rx.lang.clojure', 'io.mantisrx.mql.shaded.rx.lang.clojure')
    transform(clojureTransformer)
    
    configurations = [project.configurations.shadedAndRelocatedConfiguration] // shadowJar should only bundle dependencies on this configuration
}

// Post-process the shadow JAR to fix string constants that shadowJar's relocate doesn't catch.
// These are method descriptor strings like "void <init>(clojure.lang.Keyword)" used by
// Clojure's compiler (via ASM's Method.getMethod()) for dynamic bytecode generation.
// We use ASM to properly rewrite these strings without corrupting the class file structure.
task fixClojureStringConstants {
    dependsOn shadowJar
    doLast {
        def jarFile = shadowJar.archiveFile.get().asFile
        def tempDir = file("${buildDir}/tmp/fixClojureStrings")
        tempDir.deleteDir()
        tempDir.mkdirs()
        
        // Extract the jar
        ant.unzip(src: jarFile, dest: tempDir)
        
        // String replacements for method descriptors (order matters - longer patterns first)
        def replacements = [
            'rx.lang.clojure': 'io.mantisrx.mql.shaded.rx.lang.clojure',
            'clojure.lang': 'io.mantisrx.mql.shaded.clojure.lang',
            'clojure.core': 'io.mantisrx.mql.shaded.clojure.core',
            'clojure.asm': 'io.mantisrx.mql.shaded.clojure.asm',
            'clojure.java': 'io.mantisrx.mql.shaded.clojure.java',
            'clojure.spec': 'io.mantisrx.mql.shaded.clojure.spec',
            'instaparse': 'io.mantisrx.mql.shaded.instaparse',
        ]
        
        // Process class files in the Clojure lang package (where Compiler lives)
        fileTree(tempDir).matching { 
            include 'io/mantisrx/mql/shaded/clojure/lang/*.class'
        }.each { classFile ->
            try {
                def bytes = classFile.bytes
                def reader = new ClassReader(bytes)
                def writer = new ClassWriter(0)
                
                def cv = new ClassVisitor(Opcodes.ASM9, writer) {
                    @Override
                    MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
                        def mv = super.visitMethod(access, name, descriptor, signature, exceptions)
                        return new MethodVisitor(Opcodes.ASM9, mv) {
                            @Override
                            void visitLdcInsn(Object value) {
                                if (value instanceof String) {
                                    String str = (String) value
                                    replacements.each { pattern, replacement ->
                                        str = str.replace(pattern, replacement)
                                    }
                                    super.visitLdcInsn(str)
                                } else {
                                    super.visitLdcInsn(value)
                                }
                            }
                        }
                    }
                }
                
                reader.accept(cv, 0)
                classFile.bytes = writer.toByteArray()
            } catch (Exception e) {
                println "Warning: Could not process ${classFile}: ${e.message}"
            }
        }
        
        // Repackage the jar
        jarFile.delete()
        ant.zip(destfile: jarFile, basedir: tempDir)
        
        // Cleanup
        tempDir.deleteDir()
    }
}

shadowJar.finalizedBy(fixClojureStringConstants)


jar {
    enabled = false // this configuration is used to produce only the shadowed jar
}
jar.dependsOn shadowJar // this configuration is used to produce only the shadowed jar

afterEvaluate {
    publishing {
      publications {
        // to remove shaded dependency from ivy.xml
        withType(IvyPublication) {
          descriptor.withXml {
            asNode()
              .dependencies
              .dependency
              .findAll {
                ['clojure',
                 'data.json',
                 'instaparse',
                 'rxclojure'
                ].contains(it.artifactId.text())
              }
              .each { it.parent().remove(it) }
          }
        }
        // to remove shaded dependency from pom.xml
        withType(MavenPublication) {
          pom.withXml {
            asNode()
              .dependencies
              .dependency
              .findAll {
                ['clojure',
                 'data.json',
                 'instaparse',
                 'rxclojure'
                ].contains(it.artifactId.text())
              }
              .each { it.parent().remove(it) }
          }
        }
      }
    }
}
