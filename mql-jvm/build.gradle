configurations {
    shadedAndRelocatedConfiguration
    implementation.extendsFrom shadedAndRelocatedConfiguration
}

repositories { 
  mavenCentral()
  maven { url "https://clojars.org/repo" }
}

compileTestJava {
    options.compilerArgs << "-Xlint:unchecked" << "-Xlint:deprecation"
}

dependencies {
  shadedAndRelocatedConfiguration 'org.clojure:clojure:1.9.0'
  shadedAndRelocatedConfiguration 'org.clojure:data.json:0.2.3'
  shadedAndRelocatedConfiguration 'instaparse:instaparse:1.4.9'
  shadedAndRelocatedConfiguration 'io.reactivex:rxjava:1.3.8'
  // rxclojure must also be shaded because it uses clojure.* classes
  shadedAndRelocatedConfiguration 'io.reactivex:rxclojure:1.0.0'
  testImplementation 'criterium:criterium:0.4.4'
  testImplementation 'org.clojure:test.check:0.9.0'
  testImplementation 'junit:junit:4.12'
  testImplementation 'org.assertj:assertj-core:3.12.2'
  testImplementation 'com.fasterxml.jackson.module:jackson-module-afterburner:2.9.9'
  testImplementation 'com.fasterxml.jackson.dataformat:jackson-dataformat-cbor:2.9.9'
  testImplementation 'com.fasterxml.jackson.core:jackson-core:2.9.9'
  testImplementation 'com.fasterxml.jackson.core:jackson-databind:2.9.9'
  testImplementation 'com.fasterxml.jackson.core:jackson-annotations:2.9.9'
}

// Disable for gradle 7.x compatibility with netflixoss
//gradle.startParameter.excludedTaskNames += "licenseMain"
//gradle.startParameter.excludedTaskNames += "licenseTest"

import com.github.jengelman.gradle.plugins.shadow.transformers.Transformer
import com.github.jengelman.gradle.plugins.shadow.transformers.TransformerContext
import shadow.org.apache.tools.zip.ZipOutputStream
import shadow.org.apache.tools.zip.ZipEntry
import org.gradle.api.file.FileTreeElement

/**
 * Custom transformer that rewrites .clj/.cljc source file CONTENTS during shading.
 * 
 * This is required because shadowJar's relocate only transforms:
 *   - .class file bytecode references
 *   - Resource paths (file locations)
 * 
 * But it does NOT transform the actual text content inside .clj source files.
 * Clojure loads and compiles .clj source files at runtime, and these files 
 * contain hardcoded namespace references like (in-ns 'clojure.core) and 
 * (import ...) that must match the relocated package structure.
 */
class ClojureSourceRelocateTransformer implements Transformer {
    private Map<String, String> relocations = [:]
    private Map<String, byte[]> transformedFiles = [:]

    void relocate(String pattern, String destination) {
        relocations[pattern] = destination
    }

    @Override
    boolean canTransformResource(FileTreeElement element) {
        def path = element.relativePath.pathString
        return path.endsWith('.clj') || path.endsWith('.cljc')
    }

    @Override
    void transform(TransformerContext context) {
        def path = context.path
        def content = context.is.getText('UTF-8')

        // Apply all relocations to the source content
        // Order matters: do more specific patterns first (rx.lang.clojure before clojure)
        // This prevents double-shading (e.g., clojure within io.mantisrx.mql.shaded.rx.lang.clojure)
        def sortedRelocations = relocations.sort { a, b -> b.key.length() <=> a.key.length() }
        
        // Use a placeholder approach to prevent double-replacement
        // First pass: replace with unique placeholders
        def placeholders = [:]
        int idx = 0
        sortedRelocations.each { pattern, destination ->
            def placeholder = "##SHADE_PLACEHOLDER_${idx}##"
            placeholders[placeholder] = destination
            
            // Replace namespace references (dot notation): clojure.core -> placeholder.core
            content = content.replace(pattern + '.', placeholder + '.')
            // Replace path references (slash notation): clojure/core -> placeholder/core  
            content = content.replace(pattern + '/', placeholder + '/')
            // Replace quoted symbols: 'clojure.core -> 'placeholder.core
            content = content.replace("'" + pattern, "'" + placeholder)
            
            idx++
        }
        
        // Second pass: replace placeholders with actual shaded names
        placeholders.each { placeholder, destination ->
            content = content.replace(placeholder, destination)
        }

        transformedFiles[path] = content.getBytes('UTF-8')
    }

    @Override
    boolean hasTransformedResource() {
        return !transformedFiles.isEmpty()
    }

    @Override
    void modifyOutputStream(ZipOutputStream os, boolean preserveFileTimestamps) {
        transformedFiles.each { path, bytes ->
            def zipEntry = new ZipEntry(path)
            os.putNextEntry(zipEntry)
            os.write(bytes)
            os.closeEntry()
        }
        transformedFiles.clear()
    }
}

shadowJar {
    classifier null // this configuration is used to produce only the shadowed jar
    
    // Apply relocations to bytecode (.class files) and resource paths
    relocate 'instaparse', 'io.mantisrx.mql.shaded.instaparse'
    relocate 'clojure', 'io.mantisrx.mql.shaded.clojure'
    relocate 'rx.lang.clojure', 'io.mantisrx.mql.shaded.rx.lang.clojure'
    
    // Also transform .clj/.cljc source file CONTENTS with the same relocations
    def clojureTransformer = new ClojureSourceRelocateTransformer()
    clojureTransformer.relocate('instaparse', 'io.mantisrx.mql.shaded.instaparse')
    clojureTransformer.relocate('clojure', 'io.mantisrx.mql.shaded.clojure')
    clojureTransformer.relocate('rx.lang.clojure', 'io.mantisrx.mql.shaded.rx.lang.clojure')
    transform(clojureTransformer)
    
    configurations = [project.configurations.shadedAndRelocatedConfiguration] // shadowJar should only bundle dependencies on this configuration
}

jar {
    enabled = false // this configuration is used to produce only the shadowed jar
}
jar.dependsOn shadowJar // this configuration is used to produce only the shadowed jar

afterEvaluate {
    publishing {
      publications {
        // to remove shaded dependency from ivy.xml
        withType(IvyPublication) {
          descriptor.withXml {
            asNode()
              .dependencies
              .dependency
              .findAll {
                ['clojure',
                 'data.json',
                 'instaparse',
                 'rxclojure'
                ].contains(it.artifactId.text())
              }
              .each { it.parent().remove(it) }
          }
        }
        // to remove shaded dependency from pom.xml
        withType(MavenPublication) {
          pom.withXml {
            asNode()
              .dependencies
              .dependency
              .findAll {
                ['clojure',
                 'data.json',
                 'instaparse',
                 'rxclojure'
                ].contains(it.artifactId.text())
              }
              .each { it.parent().remove(it) }
          }
        }
      }
    }
}
